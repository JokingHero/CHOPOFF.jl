<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Find all off-targets · CHOPOFF.jl</title><meta name="title" content="Find all off-targets · CHOPOFF.jl"/><meta property="og:title" content="Find all off-targets · CHOPOFF.jl"/><meta property="twitter:title" content="Find all off-targets · CHOPOFF.jl"/><meta name="description" content="Documentation for CHOPOFF.jl."/><meta property="og:description" content="Documentation for CHOPOFF.jl."/><meta property="twitter:description" content="Documentation for CHOPOFF.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/theme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="CHOPOFF.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="CHOPOFF.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../abstract_gRNA/">Abstract gRNA</a></li><li><a class="tocitem" href="../find_potential_ot/">Find potential off-targets</a></li><li><a class="tocitem" href="../align_gRNA/">Align gRNA and off-target</a></li><li><a class="tocitem" href="../alignment_free/">Alignment-free filters for gRNAs</a></li><li class="is-active"><a class="tocitem" href>Find all off-targets</a><ul class="internal"><li><a class="tocitem" href="#Fastest-method-with-symbolic-alignments-and-prefix-hashes"><span>Fastest method with symbolic alignments and prefix hashes</span></a></li><li><a class="tocitem" href="#Prefix-Suffix-partial-alignment"><span>Prefix-Suffix partial alignment</span></a></li><li><a class="tocitem" href="#Vantage-Point-tree"><span>Vantage-Point tree</span></a></li><li><a class="tocitem" href="#Experiments-with-FM-index"><span>Experiments with FM-index</span></a></li><li><a class="tocitem" href="#VCF"><span>VCF</span></a></li></ul></li><li><a class="tocitem" href="../utils/">Utils</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Find all off-targets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Find all off-targets</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JokingHero/CHOPOFF.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Find-all-off-targets"><a class="docs-heading-anchor" href="#Find-all-off-targets">Find all off-targets</a><a id="Find-all-off-targets-1"></a><a class="docs-heading-anchor-permalink" href="#Find-all-off-targets" title="Permalink"></a></h1><h2 id="Fastest-method-with-symbolic-alignments-and-prefix-hashes"><a class="docs-heading-anchor" href="#Fastest-method-with-symbolic-alignments-and-prefix-hashes">Fastest method with symbolic alignments and prefix hashes</a><a id="Fastest-method-with-symbolic-alignments-and-prefix-hashes-1"></a><a class="docs-heading-anchor-permalink" href="#Fastest-method-with-symbolic-alignments-and-prefix-hashes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.build_prefixHashDB" href="#CHOPOFF.build_prefixHashDB"><code>CHOPOFF.build_prefixHashDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">name::String,
    genomepath::String,
    motif::Motif,
    storage_dir::String,
    hash_len::Int = min(length_noPAM(motif) - motif.distance, 16);
    reuse_saved::Bool = true)</code></pre><p>Prepare prefixHashDB index for future searches using <code>search_prefixHashDB</code>.</p><p>Will return a path to the database location, same as <code>storage_dir</code>. If interested with searches within distance 4, preferably use <code>prefix_len</code> of 8 or 9. You can also play with <code>hash_len</code> parameter, but keeping it at 16 should be close to optimal.</p><p><strong>Arguments</strong></p><p><code>name</code> - Your preferred name for this index for easier identification.</p><p><code>genomepath</code> - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with &quot;.fai&quot; extension.</p><p><code>motif</code>   - Motif defines what kind of gRNA to search for.</p><p><code>storage_dir</code>  - Folder path to the where index will be saved with name <code>linearDB.bin</code> and many prefix files.</p><p><code>hash_len</code> - Length of the hash in bp. At maximum 16.</p><p><code>reuse_saved</code> - Whether to reuse paths that were saved for Cas9 distance 4 and prefix 16.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;prefixHashDB&quot;)
mkpath(db_path)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a prefixHashDB
build_prefixHashDB(
    &quot;samirandom&quot;, genome, 
    Motif(&quot;Cas9&quot;), 
    db_path)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(tdir, &quot;prefixHashDB&quot;, &quot;results.csv&quot;)
search_prefixHashDB(db_path, guides, res_path; distance = 3)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 3)
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.search_prefixHashDB" href="#CHOPOFF.search_prefixHashDB"><code>CHOPOFF.search_prefixHashDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_prefixHashDB(
    storage_dir::String, 
    guides::Vector{LongDNA{4}}, 
    output_file::String;
    distance::Int = 3,
    early_stopping::Vector{Int} = Int.(floor.(exp.(0:distance))))</code></pre><p>Find all off-targets for <code>guides</code> within distance of <code>dist</code> using prefixHashDB located at <code>storage_dir</code>. Uses early stopping to stop searching when a guide passes a limit on number of off-targets. This method does not  keep track of the off-target locations and does not filter overlapping off-targets, therefore it might hit the  early stopping condition a little earlier than intended.</p><p>Assumes your guides do not contain PAM, and are all in the same direction as  you would order for the lab e.g.:</p><pre><code class="nohighlight hljs">5&#39; - ...ACGTCATCG NGG - 3&#39;  -&gt; will be input: ...ACGTCATCG
     guide        PAM
    
3&#39; - CCN GGGCATGCT... - 5&#39;  -&gt; will be input: ...AGCATGCCC
     PAM guide</code></pre><p><strong>Arguments</strong></p><p><code>output_file</code> - Path and name for the output file, this will be comma separated table, therefore <code>.csv</code> extension is preferred.  This search will create intermediate files which will have same name as <code>output_file</code>, but with a sequence prefix. Final file will contain all those intermediate files.</p><p><code>distance</code> - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.</p><p><code>early_stopping</code> - Integer vector. Early stopping condition. For example for distance 2, we need vector with 3 values e.g. [1, 1, 5]. Which means we will search with &quot;up to 1 offtargets within distance 0&quot;, &quot;up to 1 offtargets within distance 1&quot;...</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;prefixHashDB&quot;)
mkpath(db_path)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a prefixHashDB
build_prefixHashDB(
    &quot;samirandom&quot;, genome, 
    Motif(&quot;Cas9&quot;), 
    db_path)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(tdir, &quot;prefixHashDB&quot;, &quot;results.csv&quot;)
search_prefixHashDB(db_path, guides, res_path; distance = 3)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 3)
</code></pre></div></section></article><h2 id="Prefix-Suffix-partial-alignment"><a class="docs-heading-anchor" href="#Prefix-Suffix-partial-alignment">Prefix-Suffix partial alignment</a><a id="Prefix-Suffix-partial-alignment-1"></a><a class="docs-heading-anchor-permalink" href="#Prefix-Suffix-partial-alignment" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.build_linearDB" href="#CHOPOFF.build_linearDB"><code>CHOPOFF.build_linearDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_linearDB(
    name::String,
    genomepath::String,
    motif::Motif,
    storage_dir::String,
    prefix_len::Int = 7)</code></pre><p>Prepare linearDB index for future searches using <code>search_linearDB</code>.</p><p>Will return a path to the database location, same as <code>storage_dir</code>. When this database is used for the guide off-target scan it is similar  to linear in performance, hence the name. There is an optimization that  if the alignment becomes impossible against the prefix we don&#39;t search the off-targets grouped inside the prefix. Therefore, it is advantageous to select much larger prefix than maximum  search distance, however in that case number of files also grows. For example, if interested with searches within distance 4, preferably use prefix length of  7 or 8.</p><p><strong>Arguments</strong></p><p><code>name</code> - Your preferred name for this index for easier identification.</p><p><code>genomepath</code> - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with &quot;.fai&quot; extension.</p><p><code>motif</code>   - Motif defines what kind of gRNA to search for.</p><p><code>storage_dir</code>  - Folder path to the where index will be saved with name <code>linearDB.bin</code> and many prefix files.</p><p><code>prefix_len</code>  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;linearDB&quot;)
mkpath(db_path)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a linearDB
build_linearDB(
    &quot;samirandom&quot;, genome, 
    Motif(&quot;Cas9&quot;), 
    db_path)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(tdir, &quot;linearDB&quot;, &quot;results.csv&quot;)
search_linearDB(db_path, guides, res_path; distance = 3)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 3)
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.search_linearDB" href="#CHOPOFF.search_linearDB"><code>CHOPOFF.search_linearDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_linearDB(
    storage_dir::String, 
    guides::Vector{LongDNA{4}}, 
    output_file::String;
    distance::Int = 4)</code></pre><p>Find all off-targets for <code>guides</code> within distance of <code>dist</code> using linearDB located at <code>storage_dir</code>.</p><p>Assumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:</p><pre><code class="nohighlight hljs">5&#39; - ...ACGTCATCG NGG - 3&#39;  -&gt; will be input: ...ACGTCATCG
     guide        PAM
    
3&#39; - CCN GGGCATGCT... - 5&#39;  -&gt; will be input: ...AGCATGCCC
     PAM guide</code></pre><p><strong>Arguments</strong></p><p><code>output_file</code> - Path and name for the output file, this will be comma separated table, therefore <code>.csv</code> extension is preferred.  This search will create intermediate files which will have same name as <code>output_file</code>, but with a sequence prefix. Final file will contain all those intermediate files.</p><p><code>distance</code> - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;linearDB&quot;)
mkpath(db_path)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a linearDB
build_linearDB(
    &quot;samirandom&quot;, genome, 
    Motif(&quot;Cas9&quot;), 
    db_path)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(tdir, &quot;linearDB&quot;, &quot;results.csv&quot;)
search_linearDB(db_path, guides, res_path; distance = 3)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 3)
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.build_motifDB" href="#CHOPOFF.build_motifDB"><code>CHOPOFF.build_motifDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_motifDB(
    name::String,
    genomepath::String,
    motif::Motif,
    storage_dir::String,
    prefix_len::Int = 7;
    skipmer_size::Int = Int(floor(length_noPAM(motif) / (motif.distance + 3))))</code></pre><p>Prepare motifDB index for future searches using <code>search_motifDB</code>.</p><p>Will return a path to the database location, same as <code>storage_dir</code>. When this database is used for the guide off-target scan it is similar  to <code>search_linearDB</code>, however additional filter is applied on top of  prefix filtering. Suffixes are used for next filter, similarly to  pigeon hole principle - depending on the size of the skipmer <code>skipmer_size</code>. For example, Cas9 off-target within distance 4 (d) might be 20bp long. We skip <code>prefix_len</code> of 7, and are left with 13bp which can be split into 3  skipmer (r) of size 4, 1bp will be left unused. However when searching within  distance of 4 and for prefix where initial alignment was of distance 3 (m) and adjustment parameter is 0 (a). We are obliged to find at least <strong>r - (d - m + a)</strong>  which is <strong>3 - (4 - 3 + 0) = 2</strong> this many skipmers inside the off-targets. </p><p>There exist also another approach which builds on the idea that it might be more efficient to find at least two kmers of smaller size (named 01*0 seed) rather than one larger kmer  (pigeon hole principle). You can use the <code>adjust</code> option for that during <code>search_linearDB</code> step.</p><p>Be sure to understand implications of using <code>motifDB</code> as using wrong parameters  on <code>skipmer_size</code> might result in leaky filtering in relation to the assumed  distance <code>dist</code> and adjustment <code>adjust</code> during search step in <code>search_motifDB</code>.</p><p><strong>Arguments</strong></p><p><code>name</code> - Your preferred name for this index for easier identification.</p><p><code>genomepath</code> - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with &quot;.fai&quot; extension.</p><p><code>motif</code>   - Motif defines what kind of gRNA to search for.</p><p><code>storage_dir</code>  - Folder path to the where index will be saved and many prefix files.</p><p><code>prefix_len</code>  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files. </p><p><code>skipmer_size</code> - Size of the skipmer as described above. Be careful when setting this too large!</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;motifDB&quot;)
mkpath(db_path)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a motifDB
build_motifDB(
    &quot;samirandom&quot;, genome, 
    Motif(&quot;Cas9&quot;), 
    db_path)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(tdir, &quot;motifDB&quot;, &quot;results.csv&quot;)
search_motifDB(db_path, guides, res_path; distance = 3)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 3)
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.search_motifDB" href="#CHOPOFF.search_motifDB"><code>CHOPOFF.search_motifDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_motifDB(
    storage_dir::String, 
    guides::Vector{LongDNA{4}}, 
    output_file::String;
    distance::Int = 3,
    adjust::Int = 0)</code></pre><p>Find all off-targets for <code>guides</code> within distance of <code>distance</code> using motifDB located at <code>storage_dir</code>.</p><p>Assumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:</p><pre><code class="nohighlight hljs">5&#39; - ...ACGTCATCG NGG - 3&#39;  -&gt; will be input: ...ACGTCATCG
     guide        PAM
    
3&#39; - CCN GGGCATGCT... - 5&#39;  -&gt; will be input: ...AGCATGCCC
     PAM guide</code></pre><p><strong>Arguments</strong></p><p><code>storage_dir</code> - Directory containing motifDB.</p><p><code>guides</code> - a vector of gRNAs without PAM.</p><p><code>output_file</code> - File to which write detailed results. This search will create intermediate  files which will have same name as output_file, but with a sequence prefix. Final file will contain all those intermediate files, and other files with sequence prefix will be deleted.</p><p><code>distance</code> - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.  </p><p><code>adjust</code> - This will be crucial parameter for tightening second layer of filtering after,  the initial prefix alignment. For example, Cas9 off-target within distance 4 (d) might be 20bp long. We skip <code>prefix_len</code> of 7, and are left with 13bp which can be split into 3 skipmers (r) of size 4,  1bp will be left unused. However when searching within distance of 4 and for prefix where initial  alignment was of distance 3 (m) and adjustment parameter is 0 (a). We are obliged to find at least  <code>r - (d - m + a)</code> which is <code>3 - (4 - 3 + 0) = 2</code> this many skipmers inside the off-targets. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;motifDB&quot;)
mkpath(db_path)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a motifDB
build_motifDB(
    &quot;samirandom&quot;, genome, 
    Motif(&quot;Cas9&quot;), 
    db_path)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(tdir, &quot;motifDB&quot;, &quot;results.csv&quot;)
search_motifDB(db_path, guides, res_path; distance = 3)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 3)
</code></pre></div></section></article><h2 id="Vantage-Point-tree"><a class="docs-heading-anchor" href="#Vantage-Point-tree">Vantage-Point tree</a><a id="Vantage-Point-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Vantage-Point-tree" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.build_treeDB" href="#CHOPOFF.build_treeDB"><code>CHOPOFF.build_treeDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_treeDB(
    name::String,
    genomepath::String,
    motif::Motif,
    storage_dir::String,
    prefix_len::Int = 7)</code></pre><p>Build a Vantage Point tree DB of offtargets for the given <code>motif</code>, DB groups off-targets by their prefixes, each prefix has its own Vantage Point tree.</p><p>Will return a path to the database location, same as <code>storage_dir</code>.</p><p>There is an optimization that if the alignment becomes impossible against the prefix we don&#39;t search the off-targets grouped inside the prefix. Therefore it is advantageous to select larger prefix than maximum  search distance, however in that case number of files also grows.</p><p><strong>Arguments</strong></p><p><code>name</code> - Your preferred name for this index for easier identification.</p><p><code>genomepath</code> - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with &quot;.fai&quot; extension.</p><p><code>motif</code>   - Motif defines what kind of gRNA to search for.</p><p><code>storage_dir</code>  - Folder path to the where index will be saved with name <code>linearDB.bin</code> and many prefix files.</p><p><code>prefix_len</code>  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;treeDB&quot;)
mkpath(db_path)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a treeDB
build_treeDB(
    &quot;samirandom&quot;, genome, 
    Motif(&quot;Cas9&quot;), 
    db_path)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(tdir, &quot;treeDB&quot;, &quot;results.csv&quot;)
search_treeDB(db_path, guides, res_path; distance = 3)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 3)
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.inspect_treeDB" href="#CHOPOFF.inspect_treeDB"><code>CHOPOFF.inspect_treeDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inspect_treeDB(
    storage_dir::String; 
    levels::Int = 5, 
    inspect_prefix::String = &quot;&quot;)</code></pre><p>See small part of the full vantage point tree of the treeDB.</p><p>TreeDB can be split based on the distance to the radius (r)  into inside (left &lt;= r) and right (outside &gt; r) nodes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;treeDB&quot;)
mkpath(db_path)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a treeDB
build_treeDB(
    &quot;samirandom&quot;, genome, 
    Motif(&quot;Cas9&quot;), 
    db_path)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(tdir, &quot;treeDB&quot;, &quot;results.csv&quot;)
search_treeDB(db_path, guides, res_path; distance = 3)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 3)


# finally, view some part of the database!
inspect_treeDB(db_path; inspect_prefix = &quot;CCGTCGC&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.search_treeDB" href="#CHOPOFF.search_treeDB"><code>CHOPOFF.search_treeDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_treeDB(
    storage_dir::String, 
    guides::Vector{LongDNA{4}}, 
    output_file::String;
    distance::Int = 3)</code></pre><p>Search previously build treeDB database for the off-targets of the <code>guides</code>. </p><p>Assumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:</p><pre><code class="nohighlight hljs">5&#39; - ...ACGTCATCG NGG - 3&#39;  -&gt; will be input: ...ACGTCATCG
     guide        PAM

3&#39; - CCN GGGCATGCT... - 5&#39;  -&gt; will be input: ...AGCATGCCC
     PAM guide</code></pre><p><strong>Arguments</strong></p><p><code>dist</code> - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.  </p><p><code>detail</code> - Path and name for the output file. This search will create intermediate  files which will have same name as detail, but with a sequence prefix. Final file will contain all those intermediate files. Leave <code>detail</code> empty if you are only  interested in off-target counts returned by the treeDB. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;treeDB&quot;)
mkpath(db_path)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a treeDB
build_treeDB(
    &quot;samirandom&quot;, genome, 
    Motif(&quot;Cas9&quot;), 
    db_path)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(tdir, &quot;treeDB&quot;, &quot;results.csv&quot;)
search_treeDB(db_path, guides, res_path; distance = 3)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 3)
</code></pre></div></section></article><h2 id="Experiments-with-FM-index"><a class="docs-heading-anchor" href="#Experiments-with-FM-index">Experiments with FM-index</a><a id="Experiments-with-FM-index-1"></a><a class="docs-heading-anchor-permalink" href="#Experiments-with-FM-index" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.build_PathTemplates" href="#CHOPOFF.build_PathTemplates"><code>CHOPOFF.build_PathTemplates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_PathTemplates(
    motif::Motif; 
    storagepath::String = &quot;&quot;, 
    mismatch_only::Bool = false, 
    restrict_to_len::Int = length_noPAM(motif),
    withPAM::Bool = false)</code></pre><p>Builds up a PathTemplates object. Stores  shortened version of all possible paths within each distance <code>d</code> mapped on the graph of all possible alignments of sequence of length <code>len</code>. Then one can use <code>templates_to_sequences_extended</code> or  <code>templates_to_sequences</code> and map guide sequence to all possible alignments quickly.</p><p><strong>Arguments</strong></p><p><code>len</code> - length of the sequence (e.g. guide - without PAM)</p><p><code>d</code> - Maximal distance on which to build the graph.</p><p><code>storagepath</code> - If not empty &quot;&quot;, will save the object under given path.</p><p><code>mismatch_only</code> - Whether to skip insertions/deletions.</p><p><code>restrict_to_len</code> - To which length ambiguity should be expanded and after which length ambiguity should be collapsed if possible.     For example: ACTG and ANNN with restriction to length 2, would result in these seqeunces: ACNN AANN AGNN ATNN     This length does not includes PAM - it applies directly to the guide seqeunce. The default is full length of the guide and its maximal distance.</p><p><code>withPAM</code> - Whether to include PAM in the paths. Default is false.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.build_fmiDB" href="#CHOPOFF.build_fmiDB"><code>CHOPOFF.build_fmiDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_fmiDB(
    genomepath::String,
    storage_dir::String)</code></pre><p>Prepare FM-index for future searches.</p><p><strong>Arguments</strong></p><p><code>genomepath</code> - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with &quot;.fai&quot; extension.</p><p><code>storage_dir</code>  - Path to the DIRECTORY where index with many files will be saved.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># prepare libs
using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
fmi_dir = joinpath(tdir, &quot;fmi&quot;)
mkpath(fmi_dir)

# use CHOPOFF example genome
genome = joinpath(vcat(splitpath(dirname(pathof(CHOPOFF)))[1:end-1], 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a fmiDB!
build_fmiDB(genome, fmi_dir)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.search_fmiDB" href="#CHOPOFF.search_fmiDB"><code>CHOPOFF.search_fmiDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_fmiDB(
    guides::Vector{LongDNA{4}}, 
    mpt::PathTemplates, 
    motif::Motif, 
    fmidbdir::String,
    output_file::String; 
    distance::Int = 2)</code></pre><p>Search FM-index for off-targets using brute-force enumeration method.</p><p><strong>Experimental! Proof-of-concept!</strong></p><p>This method uses <code>PathTemplates</code> build on top of <code>Motif</code> to enumerate all possible off-target sequences, next, these sequences are found in the genome using FM-index. This method is impractically slow above distance of 2.</p><p><strong>Arguments</strong></p><p><code>guides</code> - a vector of gRNAs without PAM.</p><p><code>mpt</code> - PathTemplates object that contains abstraction for all possible alignments</p><p><code>motif</code> - Motif defines what kind of gRNA to search for. Has to be compatible with <code>mpt</code>.</p><p><code>fmidbdir</code>   - Path to the folder where FM-index was build using <code>build_fmi</code>.</p><p><code>output_file</code>  - Where output will be saved.</p><p><code>distance</code>  - Search distance, maximum of 2 is practical.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># prepare libs
using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
fmi_dir = joinpath(tdir, &quot;fmi&quot;)
mkpath(fmi_dir)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))
# build FM-index
build_fmiDB(genome, fmi_dir)
motif = Motif(&quot;Cas9&quot;; distance = 1)
mpt = build_PathTemplates(motif; withPAM = true) # its important to add PAM here!

# prepare output folder
res_dir = joinpath(tdir, &quot;results&quot;)
mkpath(res_dir)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(res_dir, &quot;results.csv&quot;)
search_fmiDB(guides, mpt, fmi_dir, res_path; distance = 1)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 1)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.build_pamDB" href="#CHOPOFF.build_pamDB"><code>CHOPOFF.build_pamDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_pamDB(
    fmidbdir::String, 
    motif::Motif; 
    storage_path::String = &quot;&quot;)</code></pre><p>Find locations of all the PAM for a given motif in the genome.</p><p>Example of what position we store for traditional Cas9 (NGG, CCN) and Cas12a (TTTV, BAAA):</p><pre><code class="nohighlight hljs">NGG  CCN TTTN  NAAA
^      ^    ^  ^</code></pre><p><strong>Arguments</strong></p><p><code>fmidbdir</code> - Path to directory with the FM-index build with <code>build_fmiDB</code>.</p><p><code>motif</code> - <code>Motif</code> defines which PAM we will locate in the genome.</p><p><code>storage_path</code>  - Path to the DIRECTORY where index will be saved.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># prepare libs
using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
fmi_dir = joinpath(tdir, &quot;fmi&quot;)
mkpath(fmi_dir)

# use CHOPOFF example genome
genome = joinpath(
    vcat(
        splitpath(dirname(pathof(CHOPOFF)))[1:end-1], 
        &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))
# build FM-index
build_fmiDB(genome, fmi_dir)

# build a pamDB
pamDB = build_pamDB(fmi_dir, Motif(&quot;Cas9&quot;))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.search_fmiDB_seed" href="#CHOPOFF.search_fmiDB_seed"><code>CHOPOFF.search_fmiDB_seed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_fmiDB_seed(
    guides::Vector{LongDNA{4}},
    fmidbdir::String, 
    genomepath::String, 
    pamDB::PAMinFMI,
    output_file::String; 
    distance::Int = 2)</code></pre><p>Search FM-index for off-targets using 01*0 seed method.  Read more here: <a href="https://www.sciencedirect.com/science/article/pii/S1570866716300028">publication</a>  and <a href="https://mikael-salson.univ-lille.fr//articles/VST_Iwoca14.pdf">pdf</a>.</p><p><strong>Experimental! Proof-of-concept!</strong></p><p><strong>Arguments</strong></p><p><code>guides</code> - a vector of gRNAs without PAM.</p><p><code>fmidbdir</code>   - Path to the folder where FM-index was build using <code>build_fmi</code>.</p><p><code>genomepath</code> - Path to the genome used to build the FM-index.</p><p><code>pamDB</code> - object build with <code>build_pamDB</code> that contains locations of the PAM inside the genome.</p><p><code>output_file</code>  - Where output will be saved.</p><p><code>distance</code>  - Search distance, maximum of 2 is practical.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># prepare libs
using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
fmi_dir = joinpath(tdir, &quot;fmi&quot;)
mkpath(fmi_dir)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))
# build FM-index
build_fmiDB(genome, fmi_dir)

# build a pamDB
motif = Motif(&quot;Cas9&quot;; distance = 1)
pamDB = build_pamDB(fmi_dir, motif)

# prepare PathTemplates
mpt = build_PathTemplates(motif)

# prepare output folder
res_dir = joinpath(tdir, &quot;results&quot;)
mkpath(res_dir)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(res_dir, &quot;results.csv&quot;)
search_fmiDB_seed(guides, fmi_dir, genome, pamDB, res_path; distance = 1)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 1)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.build_binaryFuseFilterDB" href="#CHOPOFF.build_binaryFuseFilterDB"><code>CHOPOFF.build_binaryFuseFilterDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_binaryFuseFilterDB(
    name::String, 
    genomepath::String, 
    motif::Motif,
    storage_dir::String;
    seed::UInt64 = UInt64(0x726b2b9d438b9d4d),
    max_iterations::Int = 10,
    precision::DataType = UInt32)</code></pre><p>Prepare hashDB index for future searches using <code>search_hashDB</code>.</p><p><strong>Arguments</strong></p><p><code>name</code> - Your preferred name for this index to ease future identification.</p><p><code>genomepath</code> - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with &quot;.fai&quot; extension.</p><p><code>motif</code>   - Motif defines what kind of gRNA to search for and at what maxium distance.</p><p><code>storage_dir</code>  - Directory to the where many files needed by the database will be saved. Naming                   of the files follows this pattern:                   BinaryFuseFilterDB_ + chromsome + .bin                  Each unique motif has its own file naming created.</p><p><code>seed</code>  - Optional. Seed is used during hashing for randomization.</p><p><code>max_iterations</code> - When finding hashing structure for binary fuse filter it might fail sometimes,                     we will retry <code>max_iterations</code> number of times though.</p><p><code>precision</code>- The higher the precision the larger the database, but also chances for error decrease dramatically.              We support UInt8, UInt16, and UInt32.</p><p><code>restrict_to_len</code> - Restrict lengths of the <code>motif</code> for the purpose of checking its presence in the genome.                     Allows for significant speedups when expanding all possible sequences for each guide, as we will expand                     up to the specified length here. For example, default setting for Cas9, would restrict standard 20bp to                     16bp for the genome presence check, for distance of 4 that would be 8 bases (4bp from the 20 - 16, and 4                      bases because of the potential extension) that have to be actually aligned in the genome.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;binaryFuseFilterDB&quot;)
mkpath(db_path)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a binaryFuseFilterDB
build_binaryFuseFilterDB(
    &quot;samirandom&quot;, genome, 
    Motif(&quot;Cas9&quot;), 
    db_path)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(tdir, &quot;binaryFuseFilterDB&quot;, &quot;results.csv&quot;)
search_binaryFuseFilterDB(db_path, guides, res_path; distance = 3)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 3)
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.search_binaryFuseFilterDB" href="#CHOPOFF.search_binaryFuseFilterDB"><code>CHOPOFF.search_binaryFuseFilterDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_binaryFuseFilterDB(
    bffddbir::String, 
    fmidbdir::String,
    genomepath::String, 
    guides::Vector{LongDNA{4}}, 
    output_file::String;
    distance::Int = 0)</code></pre><p>Find all off-targets for <code>guides</code> within distance of <code>dist</code> using BinaryFuseFilterDB located at <code>storage_dir</code>.</p><p>Assumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:</p><pre><code class="nohighlight hljs">5&#39; - ...ACGTCATCG NGG - 3&#39;  -&gt; will be input: ...ACGTCATCG
     guide        PAM
    
3&#39; - CCN GGGCATGCT... - 5&#39;  -&gt; will be input: ...AGCATGCCC
     PAM guide</code></pre><p><strong>Arguments</strong></p><p><code>bffdbdir</code> - Folder location where BinaryFuseFilterDB is stored at.</p><p><code>fmidbdir</code> - Folder location where FM-index is build.</p><p><code>guides</code> - Vector of your guides, without PAM.</p><p><code>output_file</code> - Path and name for the output file, this will be comma separated table, therefore <code>.csv</code> extension is preferred.  This search will create intermediate files which will have same name as <code>output_file</code>, but with a sequence prefix. Final file will contain all those intermediate files.</p><p><code>distance</code> - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;binaryFuseFilterDB&quot;)
mkpath(db_path)

# use CHOPOFF example genome
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))

# build a binaryFuseFilterDB
build_binaryFuseFilterDB(
    &quot;samirandom&quot;, genome, 
    Motif(&quot;Cas9&quot;), 
    db_path)

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)
    
# finally, make results!
res_path = joinpath(tdir, &quot;binaryFuseFilterDB&quot;, &quot;results.csv&quot;)
search_binaryFuseFilterDB(db_path, guides, res_path; distance = 3)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(res_path))

# filter results by close proximity
res = filter_overlapping(res, 23)

# summarize results into a table of counts by distance
summary = summarize_offtargets(res; distance = 3)
</code></pre></div></section></article><h2 id="VCF"><a class="docs-heading-anchor" href="#VCF">VCF</a><a id="VCF-1"></a><a class="docs-heading-anchor-permalink" href="#VCF" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.build_vcfDB" href="#CHOPOFF.build_vcfDB"><code>CHOPOFF.build_vcfDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_vcfDB(
    name::String, 
    genomepath::String, 
    vcfpath::String,
    motif::Motif,
    storage_path::String,
    hash_len::Int = min(length_noPAM(motif) - motif.distance, 16);
    reuse_saved::Bool = true,
    variant_overlaps = true)</code></pre><p>Builds a database of all potential off-targets that overlap any of the variants in the VCF file. It supports combinations of variants that are close to each other, will report all possible combinations of  variants. This database uses simialr principles to <code>prefixHashDB</code>, also utilizes hashed prefix of specific length. In case of troubles with loading of VCF files, the only fields that we use are ID, CHROM, POS, REF, ALT, so its  often possible to remove INFO field and other unnecesary fields which may cause troubles.</p><p><strong>Arguments</strong></p><p><code>name</code> - Your preferred name for this index for future identification.</p><p><code>genomepath</code> - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with &quot;.fai&quot; extension.</p><p><code>vcfpath</code> - Path to the VCF file, it has to be compatible with your genome.</p><p><code>motif</code>   - Motif defines what kind of gRNA to search for.</p><p><code>storage_path</code>  - Path to the where index will be saved. Normally, it includes &quot;.bin&quot; extension.</p><p><code>hash_len</code> - length of the prefix that is stored inside the hash</p><p><code>reuse_saved</code> - Whether to reuse paths that were saved for Cas9 distance 4 and prefix 16.</p><p><code>variant_overlaps</code> - Whether to check for all potential combinations of alternate alleles for nearby variants.     Only use with small VCF files! Preferably only run for specific variants.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># prepare libs
using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;vcfDB.bin&quot;)

# use CHOPOFF example genome and vcf file
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))
vcf = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;artificial.vcf&quot;))

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)

# example VCF file
build_vcfDB(
    &quot;samirandom&quot;, genome, vcf,
    Motif(&quot;Cas9&quot;; distance = 2, ambig_max = 3),
    db_path)

# search using vcfDB
output_file = joinpath(tdir, &quot;output.csv&quot;)
search_vcfDB(db_path, guides, output_file)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(output_file))
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CHOPOFF.search_vcfDB" href="#CHOPOFF.search_vcfDB"><code>CHOPOFF.search_vcfDB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_vcfDB(
    storage_path::String, 
    guides::Vector{LongDNA{4}}, 
    output_file::String;
    distance::Int = 3,
    early_stopping::Vector{Int} = Int.(floor.(exp.(0:distance))))</code></pre><p>Find all off-targets for <code>guides</code> within distance of <code>dist</code> using vcfDB located at <code>storage_dir</code>. Uses early stopping to stop searching when a guide passes a limit on number of off-targets. This method does not  keep track of the off-target locations and does not filter overlapping off-targets, therefore it might hit the  early stopping condition a little earlier than intended. Especially, when variants have multiple ALT and  multiple variants are overlapping off-targets, this function will report each combination of the overlapping variants. Each of these combinations will also count towards early stopping condition.</p><p>Assumes that your guides do not contain PAM, and are all in the same direction as  you would order for the lab e.g.:</p><pre><code class="nohighlight hljs">5&#39; - ...ACGTCATCG NGG - 3&#39;  -&gt; will be input: ...ACGTCATCG
     guide        PAM
    
3&#39; - CCN GGGCATGCT... - 5&#39;  -&gt; will be input: ...AGCATGCCC
     PAM guide</code></pre><p><strong>Arguments</strong></p><p><code>output_file</code> - Path and name for the output file, this will be comma separated table, therefore <code>.csv</code> extension is preferred.  This search will create intermediate files which will have same name as <code>output_file</code>, but with a sequence prefix. Final file will contain all those intermediate files.</p><p><code>distance</code> - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.</p><p><code>early_stopping</code> - Integer vector. Early stopping condition. For example for distance 2, we need vector with 3 values e.g. [1, 1, 5]. Which means we will search with &quot;up to 1 offtargets within distance 0&quot;, &quot;up to 1 offtargets within distance 1&quot;...</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># prepare libs
using CHOPOFF, BioSequences

# make a temporary directory
tdir = tempname()
db_path = joinpath(tdir, &quot;vcfDB.bin&quot;)

# use CHOPOFF example genome and vcf file
chopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]
genome = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;genome&quot;, &quot;semirandom.fa&quot;))
vcf = joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;artificial.vcf&quot;))

# load up example gRNAs
guides_s = Set(readlines(joinpath(vcat(chopoff_path, 
    &quot;test&quot;, &quot;sample_data&quot;, &quot;guides.txt&quot;))))
guides = LongDNA{4}.(guides_s)

# example VCF file
build_vcfDB(
    &quot;samirandom&quot;, genome, vcf,
    Motif(&quot;Cas9&quot;; distance = 2, ambig_max = 3),
    db_path)

# search using vcfDB
output_file = joinpath(tdir, &quot;output.csv&quot;)
search_vcfDB(db_path, guides, output_file)

# load results
using DataFrames, CSV
res = DataFrame(CSV.File(output_file))
</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../alignment_free/">« Alignment-free filters for gRNAs</a><a class="docs-footer-nextpage" href="../utils/">Utils »</a><div class="flexbox-break"></div><p class="footer-message">Made with ♥ by Kornel Labun.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Monday 12 May 2025 13:07">Monday 12 May 2025</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
