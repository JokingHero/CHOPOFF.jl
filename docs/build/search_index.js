var documenterSearchIndex = {"docs":
[{"location":"abstract_gRNA/#Abstract-gRNA","page":"Abstract gRNA","title":"Abstract gRNA","text":"","category":"section"},{"location":"abstract_gRNA/","page":"Abstract gRNA","title":"Abstract gRNA","text":"To encapsulate motifs that we search for on the genome, we can use abstract definition of gRNA/off-target, which is defined in Motif data structure.","category":"page"},{"location":"abstract_gRNA/","page":"Abstract gRNA","title":"Abstract gRNA","text":"Motif\nlength_noPAM\nsetdist\nsetambig","category":"page"},{"location":"abstract_gRNA/#ARTEMIS.Motif","page":"Abstract gRNA","title":"ARTEMIS.Motif","text":"Motif(\n    alias::String, \n    fwdmotif::String, \n    fwdpam::String, \n    forward_strand::Bool = true, \n    reverse_strand::Bool = true, \n    distance::Int = 4, \n    extends5::Bool = true,\n    ambig_max::Int = 5)\n\nMotif(alias::String)\n\nMotif defines what we search on the genome, what can be identified as an off-target.\n\nArguments\n\nalias - alias of the motif for easier identification e.g. Cas9\n\nfwdmotif - Motif that indicates where is PAM inside fwdpam.     For example for Cas9 it is 20*N + XXX: NNNNNNNNNNNNNNNNNNNNXXX\n\nfwdpam   - Motif in 5'-3' that will be matched on the reference (without the X).              For example for Cas9 it is 20*X + NGG:              XXXXXXXXXXXXXXXXXXXXNGG\n\nforward  - If false will not match to the forward reference strand.\n\nreverse  - If false will not match to the reverse reference strand.\n\ndistance - How many extra nucleotides are needed for a search? This              will indicate within what distance we can search for off-targets.              When we don't have those bases we use DNA_Gap.\n\nextend5  - Defines how off-targets will be aligned to the guides and where              extra nucleotides will be added for alignment within distance. Whether              to extend in the 5' and 3' direction. Cas9 is extend5 = true.\n\nambig_max- How many ambiguous bases are allowed in the pattern?\n\nExample for Cas9 where we want to search for off-targets within distance of 4:\n  alias:    Cas9\n  fwdmotif: NNNNNNNNNNNNNNNNNNNNXXX\n  fwdpam:   XXXXXXXXXXXXXXXXXXXXNGG\n  forward:  true\n  reverse:  true\n  distance: 4\n  extend5:  true\n  ambig_max:5 \n\nAlignments will be performed from opposite to the extension direction (which is defined by extend5).\n\nExamples\n\njulia> Motif(\"Cas9\")\nMotif(\"Cas9\", NNNNNNNNNNNNNNNNNNNNNGG, CCNNNNNNNNNNNNNNNNNNNNN, 21:23, 1:3, 3, true, 0)\n\njulia> Motif(\"test name\", \"NNNNNNNNNNNNNNNNNNNNXXX\", \"XXXXXXXXXXXXXXXXXXXXNGG\", true, true, 3, true, 5)\nMotif(\"test name\", NNNNNNNNNNNNNNNNNNNNNGG, CCNNNNNNNNNNNNNNNNNNNNN, 21:23, 1:3, 3, true, 5)\n\n\n\n\n\n","category":"type"},{"location":"abstract_gRNA/#ARTEMIS.length_noPAM","page":"Abstract gRNA","title":"ARTEMIS.length_noPAM","text":"length_noPAM(motif::Motif)\n\nCalculate what is the length of the motif, without extension, and without PAM. Effectively, size of the gRNA.\n\nExamples\n\njulia> length_noPAM(Motif(\"Cas9\"))\n20\n\n\n\n\n\n","category":"function"},{"location":"abstract_gRNA/#ARTEMIS.setdist","page":"Abstract gRNA","title":"ARTEMIS.setdist","text":"setdist(motif::Motif, distance::Int)\n\nSet the distance (maximum value of allowed mismatches, deletion, insertions)  that are allowed during alignment.\n\nExamples\n\njulia> setdist(Motif(\"Cas9\"), 15)\nMotif(\"Cas9\", NNNNNNNNNNNNNNNNNNNNNGG, CCNNNNNNNNNNNNNNNNNNNNN, 21:23, 1:3, 15, true, 0)\n\n\n\n\n\n","category":"function"},{"location":"abstract_gRNA/#ARTEMIS.setambig","page":"Abstract gRNA","title":"ARTEMIS.setambig","text":"setambig(motif::Motif, ambig::Int)\n\nSet the ambiguity (how many ambiguous bases are allowed, not counting PAM, not counting extension) level for motif.\n\nExamples\n\njulia> setambig(Motif(\"Cas9\"), 15)\nMotif(\"Cas9\", NNNNNNNNNNNNNNNNNNNNNGG, CCNNNNNNNNNNNNNNNNNNNNN, 21:23, 1:3, 3, true, 15)\n\n\n\n\n\n","category":"function"},{"location":"align_gRNA/#Align-gRNA-and-off-target","page":"Align gRNA and off-target","title":"Align gRNA and off-target","text":"","category":"section"},{"location":"align_gRNA/","page":"Align gRNA and off-target","title":"Align gRNA and off-target","text":"isinclusive\nhamming\nlevenshtein\nAln\nalign","category":"page"},{"location":"align_gRNA/#ARTEMIS.isinclusive","page":"Align gRNA and off-target","title":"ARTEMIS.isinclusive","text":"isinclusive(x::S, y::S) where {S<:BioSymbol}\n\nCheck whether x contains all options of y or y contains all options of x. Can be used as replacement in place of BioSequences.iscompatible or BioSequences.isequal.\n\nExamples\n\njulia> isinclusive(DNA_N, DNA_A)\ntrue\n\njulia> isinclusive(DNA_W, DNA_R) # W is (A/T), R is (A/G)\nfalse\n\njulia> isinclusive(DNA_W, DNA_A)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"align_gRNA/#ARTEMIS.hamming","page":"Align gRNA and off-target","title":"ARTEMIS.hamming","text":"hamming(s1::T, s2::K, ismatch = iscompatible) where {T <: BioSequence, K <: BioSequence}\n\nCheck Hamming distance between s1 and s2 using as matching definition ismatch. Should be faster than pairalign(HammingDistance(), s1, s2). Make sure inputs are of the  same length.\n\nExamples\n\njulia> hamming(dna\"ACGC\", dna\"AWRC\")\n1\n\n\n\n\n\n","category":"function"},{"location":"align_gRNA/#ARTEMIS.levenshtein","page":"Align gRNA and off-target","title":"ARTEMIS.levenshtein","text":"levenshtein(guide::T, ref::K, k::Int = 4,\n    ismatch::Function = iscompatible) where {T <: BioSequence, K <: BioSequence}\n\nCalculate Levenshtein distance bounded by k maximum edit distance with a twist for guide + off-target comparisons.\n\nLevenshtein distance is the minimum number of operations (consisting of insertions, deletions, substitutions of a single character) required to change one string into the other. guide input sequence is a gRNA sequence, ref input is reference sequence with expansion on the 3' end of k bases. This extension will not count toward the score, if it is not covered with aligned guide. Return k + 1, if distance is higher than k and terminate early. This function should be 10x faster than pairalign(LevenshteinDistance(), guide, ref, distance_only = true).\n\nNotice that guide and ref have to be oriented towards left side e.g. PAM-guide, and PAM-offtarget-extension! Take a look at the examples below to understand why.\n\nExamples\n\njulia> levenshtein(dna\"ATGA\", dna\"AGACCT\") # CCT as extension of the ref does not count towards the score in optimal alignment\n1\n\njulia> levenshtein(dna\"ATGATCG\", dna\"AGAAATCGATG\") # ATG does not count in optimal alignment ATG--ATCG/A-GAAATCG\n3\n\n\n\n\n\n","category":"function"},{"location":"align_gRNA/#ARTEMIS.Aln","page":"Align gRNA and off-target","title":"ARTEMIS.Aln","text":"struct Aln\n    guide::String\n    ref::String\n    dist::Int\nend\n\nSimple data structure to hold information on the optimal alignment. Therefore guide and ref may contain DNA_Gap as these are aligned sequences. Function align returns this object.\n\n\n\n\n\n","category":"type"},{"location":"align_gRNA/#ARTEMIS.align","page":"Align gRNA and off-target","title":"ARTEMIS.align","text":"align(guide::T, ref::K, k::Int = 4,\n    ismatch::Function = iscompatible) where {T <: BioSequence, K <: BioSequence}\n\nCalculate Levenshtein distance bounded by k maximum edit distance with a twist for guide + off-target comparisons, but return also the alignment as an Align object.\n\nLevenshtein distance is the minimum number of operations (consisting of insertions, deletions, substitutions of a single character) required to change one string into the other. guide input sequence is a gRNA sequence, ref input is reference sequence with expansion on the 3' end of k bases. This extension will not count toward the score, if it is not covered with aligned guide. Return k + 1, if distance is higher than k and terminate early.\n\nNotice that guide and ref have to be oriented towards left side e.g. PAM-guide, and PAM-offtarget-extension! Take a look at the examples below to understand why.\n\nExamples\n\njulia> align(dna\"ATGA\", dna\"AGACCT\") # CCT as extension of the ref does not count towards the score in optimal alignment\nAln(\"ATGA\", \"A-GA\", 1)\n\njulia> align(dna\"ATGATCG\", dna\"AGAAATCGATG\") # ATG does not count\nAln(\"ATG--ATCG\", \"A-GAAATCG\", 3)\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#Find-all-off-targets","page":"Find all off-targets","title":"Find all off-targets","text":"","category":"section"},{"location":"find_ot/#Prefix-Suffix-partial-alignment","page":"Find all off-targets","title":"Prefix-Suffix partial alignment","text":"","category":"section"},{"location":"find_ot/","page":"Find all off-targets","title":"Find all off-targets","text":"build_linearDB\nsearch_linearDB\n\nbuild_motifDB\nsearch_motifDB","category":"page"},{"location":"find_ot/#ARTEMIS.build_linearDB","page":"Find all off-targets","title":"ARTEMIS.build_linearDB","text":"build_linearDB(\n    name::String,\n    genomepath::String,\n    motif::Motif,\n    storage_dir::String,\n    prefix_len::Int = 7)\n\nPrepare linearDB index for future searches using search_linearDB.\n\nWill return a path to the database location, same as storage_dir. When this database is used for the guide off-target scan it is similar  to linear in performance, hence the name. There is an optimization that  if the alignment becomes impossible against the prefix we don't search the off-targets grouped inside the prefix. Therefore, it is advantageous to select much larger prefix than maximum  search distance, however in that case number of files also grows. For example, if interested with searches within distance 4, preferably use prefix length of  7 or 8.\n\nArguments\n\nname - Your preferred name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_dir  - Folder path to the where index will be saved with name linearDB.bin and many prefix files.\n\nprefix_len  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files.\n\nExamples\n\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"linearDB\")\nmkpath(db_path)\n\n# use ARTEMIS example genome\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a linearDB\nbuild_linearDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"linearDB\", \"results.csv\")\nsearch_linearDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res, 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#ARTEMIS.search_linearDB","page":"Find all off-targets","title":"ARTEMIS.search_linearDB","text":"search_linearDB(\n    storage_dir::String, \n    guides::Vector{LongDNA{4}}, \n    output_file::String;\n    distance::Int = 4)\n\nFind all off-targets for guides within distance of dist using linearDB located at storage_dir.\n\nAssumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n    \n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\noutput_file - Path and name for the output file, this will be comma separated table, therefore .csv extension is preferred.  This search will create intermediate files which will have same name as output_file, but with a sequence prefix. Final file will contain all those intermediate files.\n\ndistance - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.\n\nExamples\n\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"linearDB\")\nmkpath(db_path)\n\n# use ARTEMIS example genome\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a linearDB\nbuild_linearDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"linearDB\", \"results.csv\")\nsearch_linearDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res, 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#ARTEMIS.build_motifDB","page":"Find all off-targets","title":"ARTEMIS.build_motifDB","text":"build_motifDB(\n    name::String,\n    genomepath::String,\n    motif::Motif,\n    storage_dir::String,\n    prefix_len::Int = 7;\n    skipmer_size::Int = Int(floor(length_noPAM(motif) / (motif.distance + 3))))\n\nPrepare motifDB index for future searches using search_motifDB.\n\nWill return a path to the database location, same as storage_dir. When this database is used for the guide off-target scan it is similar  to search_linearDB, however additional filter is applied on top of  prefix filtering. Suffixes are used for next filter, similarly to  pigeon hole principle - depending on the size of the skipmer skipmer_size. For example, Cas9 off-target within distance 4 (d) might be 20bp long. We skip prefix_len of 7, and are left with 13bp which can be split into 3  skipmer (r) of size 4, 1bp will be left unused. However when searching within  distance of 4 and for prefix where initial alignment was of distance 3 (m) and adjustment parameter is 0 (a). We are obliged to find at least k - (d - m + a)  which is 3 - (4 - 3 + 0) = 2 this many skipmers inside the off-targets. \n\nThere exist also another approach which builds on the idea that it might be more efficient to find at least two kmers of smaller size (named 01*0 seed) rather than one larger kmer  (pigeon hole principle). You can use the adjust option for that during search_linearDB step.\n\nBe sure to understand implications of using motifDB as using wrong parameters  on skipmer_size might result in leaky filtering in relation to the assumed  distance dist and adjustment adjust during search step in search_motifDB.\n\nArguments\n\nname - Your preferred name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_dir  - Folder path to the where index will be saved and many prefix files.\n\nprefix_len  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files. \n\nskipmer_size - Size of the skipmer as described above. Be careful when setting this too large!\n\nExamples\n\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"motifDB\")\nmkpath(db_path)\n\n# use ARTEMIS example genome\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a motifDB\nbuild_motifDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"motifDB\", \"results.csv\")\nsearch_motifDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res, 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#ARTEMIS.search_motifDB","page":"Find all off-targets","title":"ARTEMIS.search_motifDB","text":"search_motifDB(\n    storage_dir::String, \n    guides::Vector{LongDNA{4}}, \n    output_file::String;\n    distance::Int = 3,\n    adjust::Int = 0)\n\nFind all off-targets for guides within distance of distance using motifDB located at storage_dir.\n\nAssumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n    \n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\nstorage_dir - Directory containing motifDB.\n\nguides - a vector of gRNAs without PAM.\n\noutput_file - File to which write detailed results. This search will create intermediate  files which will have same name as output_file, but with a sequence prefix. Final file will contain all those intermediate files, and other files with sequence prefix will be deleted.\n\ndistance - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.  \n\nadjust - This will be crucial parameter for tightening second layer of filtering after,  the initial prefix alignment. For example, Cas9 off-target within distance 4 (d) might be 20bp long. We skip prefix_len of 7, and are left with 13bp which can be split into 3 skipmers (r) of size 4,  1bp will be left unused. However when searching within distance of 4 and for prefix where initial  alignment was of distance 3 (m) and adjustment parameter is 0 (a). We are obliged to find at least  k - (d - m + a) which is 3 - (4 - 3 + 0) = 2 this many skipmers inside the off-targets. \n\nExamples\n\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"motifDB\")\nmkpath(db_path)\n\n# use ARTEMIS example genome\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a motifDB\nbuild_motifDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"motifDB\", \"results.csv\")\nsearch_motifDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res, 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#Vantage-Point-tree","page":"Find all off-targets","title":"Vantage-Point tree","text":"","category":"section"},{"location":"find_ot/","page":"Find all off-targets","title":"Find all off-targets","text":"build_treeDB\ninspect_treeDB\nsearch_treeDB","category":"page"},{"location":"find_ot/#ARTEMIS.build_treeDB","page":"Find all off-targets","title":"ARTEMIS.build_treeDB","text":"build_treeDB(\n    name::String,\n    genomepath::String,\n    motif::Motif,\n    storage_dir::String,\n    prefix_len::Int = 7)\n\nBuild a Vantage Point tree DB of offtargets for the given motif, DB groups off-targets by their prefixes, each prefix has its own Vantage Point tree.\n\nWill return a path to the database location, same as storage_dir.\n\nThere is an optimization that if the alignment becomes impossible against the prefix we don't search the off-targets grouped inside the prefix. Therefore it is advantageous to select larger prefix than maximum  search distance, however in that case number of files also grows.\n\nArguments\n\nname - Your preferred name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_dir  - Folder path to the where index will be saved with name linearDB.bin and many prefix files.\n\nprefix_len  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files. \n\nExamples\n\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"treeDB\")\nmkpath(db_path)\n\n# use ARTEMIS example genome\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a treeDB\nbuild_treeDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"treeDB\", \"results.csv\")\nsearch_treeDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res, 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#ARTEMIS.inspect_treeDB","page":"Find all off-targets","title":"ARTEMIS.inspect_treeDB","text":"inspect_treeDB(\n    storage_dir::String; \n    levels::Int = 5, \n    inspect_prefix::String = \"\")\n\nSee small part of the full vantage point tree of the treeDB.\n\nTreeDB can be split based on the distance to the radius (r)  into inside (left <= r) and right (outside > r) nodes.\n\nExamples\n\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"treeDB\")\nmkpath(db_path)\n\n# use ARTEMIS example genome\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a treeDB\nbuild_treeDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"treeDB\", \"results.csv\")\nsearch_treeDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res, 3)\n\n\n# finally, view some part of the database!\ninspect_treeDB(db_path; inspect_prefix = \"CCGTCGC\")\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#ARTEMIS.search_treeDB","page":"Find all off-targets","title":"ARTEMIS.search_treeDB","text":"search_treeDB(\n    storage_dir::String, \n    guides::Vector{LongDNA{4}}, \n    output_file::String;\n    distance::Int = 3)\n\nSearch previously build treeDB database for the off-targets of the guides. \n\nAssumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n\n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\ndist - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.  \n\ndetail - Path and name for the output file. This search will create intermediate  files which will have same name as detail, but with a sequence prefix. Final file will contain all those intermediate files. Leave detail empty if you are only  interested in off-target counts returned by the treeDB. \n\nExamples\n\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"treeDB\")\nmkpath(db_path)\n\n# use ARTEMIS example genome\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a treeDB\nbuild_treeDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"treeDB\", \"results.csv\")\nsearch_treeDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res, 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#FM-index","page":"Find all off-targets","title":"FM-index","text":"","category":"section"},{"location":"find_ot/","page":"Find all off-targets","title":"Find all off-targets","text":"build_PathTemplates\nbuild_fmiDB\nsearch_fmiDB\n\nbuild_pamDB\nsearch_fmiDB_seed","category":"page"},{"location":"find_ot/#ARTEMIS.build_PathTemplates","page":"Find all off-targets","title":"ARTEMIS.build_PathTemplates","text":"build_PathTemplates(len::Int, d::Int; storagepath::String = \"\", mismatch_only::Bool = false)\n\nBuilds up a PathTemplates object. Stores  shortened version of all possible paths within each distance d mapped on the graph of all possible alignments of sequence of length len. Then one can use templates_to_sequences_extended or  templates_to_sequences and map guide sequence to all possible alignments quickly.\n\nArguments\n\nlen - length of the sequence (e.g. guide - without PAM)\n\nd - Maximal distance on which to build the graph.\n\nstoragepath - If not empty \"\", will save the object under given path.\n\nmismatch_only - Whether to skip insertions/deletions.\n\n\n\n\n\nbuild_PathTemplates(motif::Motif; storagepath::String = \"\", mismatch_only::Bool = false)\n\nBuilds up a PathTemplates object. Stores  shortened version of all possible paths for given Motif.  Afterwards use templates_to_sequences_extended or  templates_to_sequences and map guide sequence to all possible alignments quickly.\n\nArguments\n\nmotif - Motif object.\n\nstoragepath - If not empty \"\", will save the object under given path.\n\nmismatch_only - Whether to skip insertions/deletions.\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#ARTEMIS.build_fmiDB","page":"Find all off-targets","title":"ARTEMIS.build_fmiDB","text":"build_fmiDB(\n    genomepath::String,\n    storage_dir::String)\n\nPrepare FM-index for future searches.\n\nArguments\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nstorage_dir  - Path to the DIRECTORY where index with many files will be saved.\n\nExamples\n\n# prepare libs\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\nfmi_dir = joinpath(tdir, \"fmi\")\nmkpath(fmi_dir)\n\n# use ARTEMIS example genome\ngenome = joinpath(vcat(splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a fmiDB!\nbuild_fmiDB(genome, fmi_dir)\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#ARTEMIS.search_fmiDB","page":"Find all off-targets","title":"ARTEMIS.search_fmiDB","text":"search_fmiDB(\n    guides::Vector{LongDNA{4}}, \n    mpt::PathTemplates, \n    motif::Motif, \n    fmidbdir::String,\n    output_file::String; \n    distance::Int = 2)\n\nSearch FM-index for off-targets using brute-force enumeration method.\n\nExperimental! Proof-of-concept!\n\nThis method uses PathTemplates build on top of Motif to enumerate all possible off-target sequences, next, these sequences are found in the genome using FM-index. This method is impractically slow above distance of 2.\n\nArguments\n\nguides - a vector of gRNAs without PAM.\n\nmpt - PathTemplates object that contains abstraction for all possible alignments\n\nmotif - Motif defines what kind of gRNA to search for. Has to be compatible with mpt.\n\nfmidbdir   - Path to the folder where FM-index was build using build_fmi.\n\noutput_file  - Where output will be saved.\n\ndistance  - Search distance, maximum of 2 is practical.\n\nExamples\n\n# prepare libs\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\nfmi_dir = joinpath(tdir, \"fmi\")\nmkpath(fmi_dir)\n\n# use ARTEMIS example genome\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# build FM-index\nbuild_fmiDB(genome, fmi_dir)\nmotif = Motif(\"Cas9\"; distance = 1)\nmpt = build_PathTemplates(motif)\n\n# prepare output folder\nres_dir = joinpath(tdir, \"results\")\nmkpath(res_dir)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(res_dir, \"results.csv\")\nsearch_fmiDB(guides, mpt, motif, fmi_dir, res_path; distance = 1)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res, 1)\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#ARTEMIS.build_pamDB","page":"Find all off-targets","title":"ARTEMIS.build_pamDB","text":"build_pamDB(\n    fmidbdir::String, \n    motif::Motif; \n    storage_path::String = \"\")\n\nFind locations of all the PAM for a given motif in the genome.\n\nExample of what position we store for traditional Cas9 (NGG, CCN) and Cpf1 (TTTN, NAAA):\n\nNGG  CCN TTTN  NAAA\n^      ^    ^  ^\n\nArguments\n\nfmidbdir - Path to directory with the FM-index build with build_fmiDB.\n\nmotif - Motif defines which PAM we will locate in the genome.\n\nstorage_path  - Path to the DIRECTORY where index will be saved.\n\nExamples\n\n# prepare libs\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\nfmi_dir = joinpath(tdir, \"fmi\")\nmkpath(fmi_dir)\n\n# use ARTEMIS example genome\ngenome = joinpath(\n    vcat(\n        splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# build FM-index\nbuild_fmiDB(genome, fmi_dir)\n\n# build a pamDB\npamDB = build_pamDB(fmi_dir, Motif(\"Cas9\"))\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#ARTEMIS.search_fmiDB_seed","page":"Find all off-targets","title":"ARTEMIS.search_fmiDB_seed","text":"search_fmiDB_seed(\n    guides::Vector{LongDNA{4}},\n    fmidbdir::String, \n    genomepath::String, \n    pamDB::PAMinFMI,\n    output_file::String; \n    distance::Int = 2)\n\nSearch FM-index for off-targets using 01*0 seed method.  Read more here: publication  and pdf.\n\nExperimental! Proof-of-concept!\n\nArguments\n\nguides - a vector of gRNAs without PAM.\n\nfmidbdir   - Path to the folder where FM-index was build using build_fmi.\n\ngenomepath - Path to the genome used to build the FM-index.\n\npamDB - object build with build_pamDB that contains locations of the PAM inside the genome.\n\noutput_file  - Where output will be saved.\n\ndistance  - Search distance, maximum of 2 is practical.\n\nExamples\n\n# prepare libs\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\nfmi_dir = joinpath(tdir, \"fmi\")\nmkpath(fmi_dir)\n\n# use ARTEMIS example genome\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# build FM-index\nbuild_fmiDB(genome, fmi_dir)\n\n# build a pamDB\nmotif = Motif(\"Cas9\"; distance = 1)\npamDB = build_pamDB(fmi_dir, motif)\n\n# prepare PathTemplates\nmpt = build_PathTemplates(motif)\n\n# prepare output folder\nres_dir = joinpath(tdir, \"results\")\nmkpath(res_dir)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(res_dir, \"results.csv\")\nsearch_fmiDB_seed(guides, fmi_dir, genome, pamDB, res_path; distance = 1)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res, 1)\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#VCF","page":"Find all off-targets","title":"VCF","text":"","category":"section"},{"location":"find_ot/","page":"Find all off-targets","title":"Find all off-targets","text":"build_vcfDB\nsearch_vcfDB","category":"page"},{"location":"find_ot/#ARTEMIS.build_vcfDB","page":"Find all off-targets","title":"ARTEMIS.build_vcfDB","text":"build_vcfDB(\n    name::String, \n    genomepath::String, \n    vcfpath::String,\n    motif::Motif;\n    storage_path::String = \"\")\n\nSearch VcfDB for off-targets for selected guides. \n\nExperimental! Proof-of-concept! \n\nThis function does not yet lists all off-targets and this will be added at a later data. Current output is a list of counts of the ambiguous off-targets by distance. Distance is restricted to 0 and 1 at the moment.\n\nArguments\n\nname - Your preferred name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nvcfpath - Path to the VCF file, it has to be compatible with your genome.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_path  - Folder path to the where index will be saved. \n\nExamples\n\n# prepare libs\nusing ARTEMIS, BioSequences\n\n# use ARTEMIS example genome and vcf file\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\nvcf = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"artificial.vcf\"))\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n\n# example VCF file\nvcf_db = build_vcfDB(\n    \"samirandom\", genome, vcf,\n    Motif(\"Cas9\"; distance = 1, ambig_max = 0))\n\n# search using vcfDB!\nvcf_res = search_vcfDB(vcf_db, guides)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#ARTEMIS.search_vcfDB","page":"Find all off-targets","title":"ARTEMIS.search_vcfDB","text":"search_vcfDB(\n    db::VcfDB,\n    guides::Vector{LongDNA{4}})\n\nSearch VcfDB for off-targets for selected guides. \n\nExperimental! Proof-of-concept! \n\nThis function does not yet lists all off-targets and this will be added at a later data. Current output is a list of counts of the ambiguous off-targets by distance. Distance is restricted to 0 and 1 at the moment.\n\nArguments\n\ndb - object built with build_vcfDB\n\nguides - a vector of gRNAs without PAM.\n\nExamples\n\n# prepare libs\nusing ARTEMIS, BioSequences\n\n# use ARTEMIS example genome and vcf file\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\nvcf = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"artificial.vcf\"))\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n\n# example VCF file\nvcf_db = build_vcfDB(\n    \"samirandom\", genome, vcf,\n    Motif(\"Cas9\"; distance = 1, ambig_max = 0))\n\n# search using vcfDB!\nvcf_res = search_vcfDB(vcf_db, guides)\n\n\n\n\n\n\n","category":"function"},{"location":"alignment_free/#Alignment-free-filters-for-gRNAs","page":"Alignment-free filters for gRNAs","title":"Alignment-free filters for gRNAs","text":"","category":"section"},{"location":"alignment_free/","page":"Alignment-free filters for gRNAs","title":"Alignment-free filters for gRNAs","text":"build_hashDB\nsearch_hashDB\nbuild_dictDB\nsearch_dictDB","category":"page"},{"location":"alignment_free/#ARTEMIS.build_hashDB","page":"Alignment-free filters for gRNAs","title":"ARTEMIS.build_hashDB","text":"build_hashDB(\n    name::String, \n    genomepath::String, \n    motif::Motif;\n    storage_path::String = \"\",\n    seed::UInt64 = UInt64(0x726b2b9d438b9d4d),\n    max_iterations::Int = 10,\n    max_count::Int = 10,\n    precision::DataType = UInt16)\n\nPrepare hashDB index for future searches using search_hashDB.\n\nArguments\n\nname - Your preferred name for this index to ease future identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_path  - Path to the where index will be saved.\n\nseed  - Optional. Seed is used during hashing for randomization.\n\nmax_iterations - When finding hashing structure for binary fuse filter it might fail sometimes,                     we will retry max_iterations number of times though.\n\nmax_count  - Above this count we put all unique off-targets into one bin.                 Put number here that is the minimum number of off-targets that you think is fine                for the distance of 1.\n\nprecision- The higher the precision the larger the database, but also chances for error decrease dramatically.              We support UInt8, UInt16, and UInt32.\n\nExamples\n\n# prepare libs\nusing ARTEMIS, BioSequences\n\n# use ARTEMIS example genome\ngenome = joinpath(\n    vcat(splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n    test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# finally, build a hashDB\nbuild_hashDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 1, ambig_max = 0))\n\n\n\n\n\n","category":"function"},{"location":"alignment_free/#ARTEMIS.search_hashDB","page":"Alignment-free filters for gRNAs","title":"ARTEMIS.search_hashDB","text":"search_hashDB(\n    db::HashDB,\n    guides::Vector{LongDNA{4}},\n    right::Bool)\n\nEstimate off-target counts for guides using hashDB stored at storage_dir.\n\nProbabilistic filter offers a guarantee that it will always be correct when a sequence  is in the set (no false negatives), but may overestimate that a sequence is in the set  while it is not (false positive) with low probability. If both columns in the results are 0,  it is guaranteed this gRNA has no off-targets in the genome!\n\nAlso, maximum count for each off-target in the database is capped, to max_count specified during building of hashDB. This means  that counts larger than max_count are no longer estimating correctly. Its likely you would not care for those guides anyhow.\n\nright argument specifies whether the database should be checked in direction from  unique off-targets which occur once to increasingly more occurring off-targets up until  max_count is reached, which may result in assuming lower than real off-target counts  (underestimate) for some of the sequences, however this approach will not reject any  gRNAs that should not be rejected and is suitable for filtering of gRNAs we do not need.  Left (right = false, or hight-counts to low-counts) approach is also supported,  which can be used for ordering of gRNAs to the best of database ability.  Left approach may overestimate counts for some gRNAs. When gRNA is reported as  off-target free it is also guaranteed to be true in both cases (low-to-high and high-to-low).\n\nExamples\n\n# prepare libs\nusing ARTEMIS, BioSequences\n\n# use ARTEMIS example genome\nARTEMIS_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(ARTEMIS_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a hashDB\ndb = build_hashDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 1, ambig_max = 0))\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(ARTEMIS_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n\n# finally, get results!\nhdb_res = search_hashDB(db, guides, false)\n\n\n\n\n\n","category":"function"},{"location":"alignment_free/#ARTEMIS.build_dictDB","page":"Alignment-free filters for gRNAs","title":"ARTEMIS.build_dictDB","text":"build_dictDB(\n    name::String, \n    genomepath::String, \n    motif::Motif;\n    storage_path::String = \"\")\n\nPrepare dictDB index for future searches using search_dictDB.\n\nArguments\n\nname - Your preferred name for this index to ease future identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_path  - Path to the where index will be saved.\n\nExamples\n\n# prepare libs\nusing ARTEMIS, BioSequences\n\n# use ARTEMIS example genome\ngenome = joinpath(vcat(splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a hashDB!\ndb = build_dictDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 1, ambig_max = 0))\n\n\n\n\n\n","category":"function"},{"location":"alignment_free/#ARTEMIS.search_dictDB","page":"Alignment-free filters for gRNAs","title":"ARTEMIS.search_dictDB","text":"search_dictDB(\n    db::DictDB,\n    guides::Vector{LongDNA{4}})\n\nSummarize off-target counts for guides using dictDB.\n\nThis is simple dictionary storing all possible off-targets and their counts for a given Motif. If you find no off-targets using this method it is guaranteed this gRNA has no off-targets in the genome! Beware that the dictionary can be very big (e.g. human genome ~ 8Gb).\n\nExamples\n\n# prepare libs\nusing ARTEMIS, BioSequences\n\n# use ARTEMIS example genome\nARTEMIS_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(ARTEMIS_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a dictDB\ndb = build_dictDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 1, ambig_max = 0))\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(ARTEMIS_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n\n# finally, get results!\nres = search_dictDB(db, guides)\n\n\n\n\n\n","category":"function"},{"location":"find_potential_ot/#Find-potential-off-targets","page":"Find potential off-targets","title":"Find potential off-targets","text":"","category":"section"},{"location":"find_potential_ot/","page":"Find potential off-targets","title":"Find potential off-targets","text":"DBInfo\ngatherofftargets!","category":"page"},{"location":"find_potential_ot/#ARTEMIS.DBInfo","page":"Find potential off-targets","title":"ARTEMIS.DBInfo","text":"DBInfo(filepath::String, name::String, motif::Motif; vcf_filepath::String = \"\")\n\nMotif defines what genome file is being used for the searches.\n\nArguments\n\nfilepath - Path to the genome file, if file is fasta (ends with .fa or .fasta or .fna)  make sure you also have fasta index file with extension .fai. Alternatively, you can use .2bit  genome file.  \n\nname - Your name for this instance of DBInfo: the genome with connection to the motif and vcf file.\n\nmotif   - Motif object defining search parameters\n\nvcf_filepath  - Optional. Path to the VCF file to include in the searches.\n\nAlignments will be performed from opposite to the extension direction (which is defined by extend5).\n\nExamples\n\n# use ARTEMIS example genome\ngenome = joinpath(vcat(splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# construct example DBInfo\nDBInfo(genome, \"Cas9_semirandom_noVCF\", Motif(\"Cas9\"))\n\n\n\n\n\n","category":"type"},{"location":"find_potential_ot/#ARTEMIS.gatherofftargets!","page":"Find potential off-targets","title":"ARTEMIS.gatherofftargets!","text":"gatherofftargets!(output::T, dbi::DBInfo) \n    where {T<:Union{Vector{String}, Vector{UInt64}, Vector{UInt128}}}\n\nGathers all off-targets that conform to the given dbi Motif.\n\nThis function appends to the output during the run, however it will also return all ambiguous  guides in return object. We use UInt64 and UInt128 to compress space that the gRNAs use. When using  large genomes or non-specific PAMs you might run out of memory when using this function.\n\nExamples\n\n# use ARTEMIS example genome\ngenome = joinpath(\n    vcat(\n        splitpath(dirname(pathof(ARTEMIS)))[1:end-1], \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# construct example DBInfo\ndbi = DBInfo(genome, \"Cas9_semirandom_noVCF\", Motif(\"Cas9\"))\n# finally gather all off-targets\nguides = Vector{String}()\nambig = gatherofftargets!(guides, dbi)\n\n\n\n\n\n","category":"function"},{"location":"#ARTEMIS.jl","page":"General","title":"ARTEMIS.jl","text":"","category":"section"},{"location":"#About","page":"General","title":"About","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Uncompromising finding of CRISPR off-targets:","category":"page"},{"location":"","page":"General","title":"General","text":"many fast alignment algorithms optimized specifically for CRISPR\nsearch for larger distances allowing for mismatches and bulges\nsupport for ambiguous bases\narbitrarily large genomes\nVCF support - with multiple overlapping SNPs\nnear-instant alignment-free off-target filtering\npruning of off-targets by their location (remove overlapping, competing off-targets)\nextensively tested\nfull framework that can be extended for your own algorithms with ease","category":"page"},{"location":"#Requirements","page":"General","title":"Requirements","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Some of the algorithms generate as many files as there are prefixes (e.g. for prefix 7 - this will make 4^7 - 16384 files). This strategy allows us to operate the searches independently on multiple cores and not get throttled when querying large number of the guides. However, some systems have artificial limits on the number of open files, for example in ubuntu 'ulimit -n' will show the limit. Increase the limits, if it creates problems for you.\nWhen using many cores for building the indexes - you have to have around ~1GB of RAM per thread.","category":"page"},{"location":"#Build-application","page":"General","title":"Build application","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"It is possible to build ARTEMIS into standalone application - which includes all dependencies and Julia into one compiled software. This is recommended method for using of ARTEMIS when you are not a developer. If you know how to code in Julia, you might make use of the whole framework using ARTEMIS as a package.","category":"page"},{"location":"","page":"General","title":"General","text":"To build a standalone application run ./build_standalone.sh script from the main directory. Script will produce binary in a \"build\" folder. Then you can run from inside that folder ./bin/ARTEMIS --help. To learn about building a database run ./bin/ARTEMIS build --help and to use existing database check out ./bin/ARTEMIS search --help. It is possible to skip testing + precompile step to speed up the build process with ./build_standalone.sh --noprecompile.","category":"page"},{"location":"","page":"General","title":"General","text":"You can alternatively download latest release from the releases page on the github.","category":"page"},{"location":"","page":"General","title":"General","text":"When using application as self-contained compiled software, you can control number of cores by setting JULIA_NUM_THREADS environment variable.","category":"page"},{"location":"#No-build-application","page":"General","title":"No-build application","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Run ARTEMIS package as an application,  without building first. From the directory of the package run:","category":"page"},{"location":"","page":"General","title":"General","text":"julia --threads 4 --project=\".\" ./src/ARTEMIS.jl --help","category":"page"},{"location":"#Quick-Use","page":"General","title":"Quick Use","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"For search of off-targets you have a couple of options:","category":"page"},{"location":"","page":"General","title":"General","text":"linearDB - most rigorously tested\nmotifDB - the fastest\ntreeDB - will work best for longer gRNAs\nfmiDB - smallest file size, very fast, but only for distances  2","category":"page"},{"location":"","page":"General","title":"General","text":"If you would like to filter or rank gRNAs to only those that are most likely off-target free you want to use hashDB or slower and much larger, but less probabilistic dictDB.","category":"page"},{"location":"","page":"General","title":"General","text":"For VCF file support use vcfDB.  For use of the framework as a Julia package consult the documentation - Public Interface section.","category":"page"},{"location":"#Support","page":"General","title":"Support","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"You can buy me a coffee to show some love and appreciation!","category":"page"},{"location":"","page":"General","title":"General","text":"<img src=\"./assets/bmc_qr.png\" width=\"25%\"/>","category":"page"},{"location":"#LICENSE","page":"General","title":"LICENSE","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Copyright (C) 2022  Kornel Labun","category":"page"},{"location":"","page":"General","title":"General","text":"License for non-commercial applications is aGPL-3.0.  For commercial applications you should acquire permission or licensing contract.","category":"page"},{"location":"","page":"General","title":"General","text":"https://tldrlegal.com/license/gnu-affero-general-public-license-v3-(agpl-3.0)","category":"page"},{"location":"","page":"General","title":"General","text":"This program is free software for non-commercial applications:  you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.","category":"page"},{"location":"","page":"General","title":"General","text":"This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.","category":"page"},{"location":"","page":"General","title":"General","text":"You should have received a copy of the GNU Affero General Public License along with this program inside LICENSE file.  If not, see https://www.gnu.org/licenses/.","category":"page"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/#gRNAs-and-kmers","page":"Utils","title":"gRNAs and kmers","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"getseq\nas_kmers\nas_skipkmers\nall_kmers\nminkmersize","category":"page"},{"location":"utils/#ARTEMIS.getseq","page":"Utils","title":"ARTEMIS.getseq","text":"getseq(n = 20, letters = ['A', 'C', 'G', 'T'])\n\nRandomize sequence of length n from letters.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ARTEMIS.as_kmers","page":"Utils","title":"ARTEMIS.as_kmers","text":"as_kmers(x::LongDNA{4}, kmer_size::Int)\n\nTransforms x into vector of kmers of size kmer_size.  All ambiguous bases will be expanded.\n\nExamples\n\njulia> as_kmers(dna\"ACTGG\", 4)\n2-element Vector{LongSequence{DNAAlphabet{4}}}:\n ACTG\n CTGG\n\n\n\n\n\n","category":"function"},{"location":"utils/#ARTEMIS.as_skipkmers","page":"Utils","title":"ARTEMIS.as_skipkmers","text":"as_skipkmers(x::LongDNA{4}, kmer_size::Int)\n\nTransforms x into vector of skip-kmers of size kmer_size.  All ambiguous bases will be expanded.  Leftover-bases are ignored!\n\nExamples\n\njulia> as_skipkmers(dna\"ACTGG\", 2)\n2-element Vector{LongSequence{DNAAlphabet{4}}}:\n AC\n TG\n\n\n\n\n\n","category":"function"},{"location":"utils/#ARTEMIS.all_kmers","page":"Utils","title":"ARTEMIS.all_kmers","text":"all_kmers(size = 4; alphabet = [DNA_A, DNA_C, DNA_G, DNA_T]\n\nMake a list of all possible kmers with givensize using bases in the alphabet. \n\nExamples\n\njulia> all_kmers(2; alphabet = [DNA_A, DNA_N])\n4-element Vector{LongSequence{DNAAlphabet{4}}}:\n AA\n AN\n NA\n NN\n\n\n\n\n\n","category":"function"},{"location":"utils/#ARTEMIS.minkmersize","page":"Utils","title":"ARTEMIS.minkmersize","text":"minkmersize(len::Int = 20, d::Int = 4)\n\nPigeon hole principle: minimum k-mer size that is required for two strings of size len to be aligned within distance of d.\n\nExamples\n\njulia> minkmersize(20, 3)\n5\n\njulia> minkmersize(20, 6)\n2\n\n\n\n\n\n","category":"function"},{"location":"utils/#Persistence","page":"Utils","title":"Persistence","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"save\nload","category":"page"},{"location":"utils/#ARTEMIS.save","page":"Utils","title":"ARTEMIS.save","text":"save(object::Any, destination::String)\n\nUses julia serializer to save the data to binary format. Read more about serialization. Notice that:\n\nThis function will overwrite destination! \nThis serialization is dependent on julia build! This means files can fail to work when reloaded across different julia builds.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ARTEMIS.load","page":"Utils","title":"ARTEMIS.load","text":"load(destination::String)\n\nLoad file saved with save function. This may not load properly files saved in other julia builds.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Summarize-off-targets","page":"Utils","title":"Summarize off-targets","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"summarize_offtargets","category":"page"},{"location":"utils/#ARTEMIS.summarize_offtargets","page":"Utils","title":"ARTEMIS.summarize_offtargets","text":"filter_overlapping(res::DataFrame, distance::Int)\n\nFilter overlapping off-targets. Remember that off-targets have their start relative to the PAM location.\n\nArguments\n\nres - DataFrame created by one of the off-target finding methods, it contains columns      such as :guide,  :chromosome, :strand, :distance, :start. \n\ndistance - To what distance from the :start do we consider the off-target to be overlapping?\n\nExamples\n\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"linearDB\")\nmkpath(db_path)\n\n# use ARTEMIS example genome\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a linearDB\nbuild_linearDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"linearDB\", \"results.csv\")\nsearch_linearDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res, 3)\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Proximity-filter","page":"Utils","title":"Proximity filter","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"filter_overlapping","category":"page"},{"location":"utils/#ARTEMIS.filter_overlapping","page":"Utils","title":"ARTEMIS.filter_overlapping","text":"filter_overlapping(res::DataFrame, distance::Int)\n\nFilter overlapping off-targets. Remember that off-targets have their start relative to the PAM location.\n\nArguments\n\nres - DataFrame created by one of the off-target finding methods, it contains columns      such as :guide,  :chromosome, :strand, :distance, :start. \n\ndistance - To what distance from the :start do we consider the off-target to be overlapping?\n\nExamples\n\nusing ARTEMIS, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"linearDB\")\nmkpath(db_path)\n\n# use ARTEMIS example genome\nartemis_path = splitpath(dirname(pathof(ARTEMIS)))[1:end-1]\ngenome = joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a linearDB\nbuild_linearDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(artemis_path, \n    \"test\", \"sample_data\", \"crispritz_results\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"linearDB\", \"results.csv\")\nsearch_linearDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res, 3)\n\n\n\n\n\n\n","category":"function"}]
}
