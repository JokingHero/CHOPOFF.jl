var documenterSearchIndex = {"docs":
[{"location":"abstract_gRNA/","page":"Abstract gRNA","title":"Abstract gRNA","text":"CollapsedDocStrings = true","category":"page"},{"location":"abstract_gRNA/#Abstract-gRNA","page":"Abstract gRNA","title":"Abstract gRNA","text":"","category":"section"},{"location":"abstract_gRNA/","page":"Abstract gRNA","title":"Abstract gRNA","text":"To encapsulate motifs that we search for on the genome, we can use abstract definition of gRNA/off-target, which is defined in Motif data structure.","category":"page"},{"location":"abstract_gRNA/","page":"Abstract gRNA","title":"Abstract gRNA","text":"Motif\nlength_noPAM\nsetdist\nsetambig","category":"page"},{"location":"abstract_gRNA/#CHOPOFF.Motif","page":"Abstract gRNA","title":"CHOPOFF.Motif","text":"Motif(\n    alias::String, \n    fwdmotif::String, \n    fwdpam::String, \n    forward_strand::Bool = true, \n    reverse_strand::Bool = true, \n    distance::Int = 4, \n    extends5::Bool = true,\n    ambig_max::Int = 5)\n\nMotif(alias::String)\n\nMotif defines what we search on the genome, what can be identified as an off-target.\n\nArguments\n\nalias - alias of the motif for easier identification e.g. Cas9\n\nfwdmotif - Motif that indicates where is PAM inside fwdpam.     For example for Cas9 it is 20*N + XXX: NNNNNNNNNNNNNNNNNNNNXXX\n\nfwdpam   - Motif in 5'-3' that will be matched on the reference (without the X).              For example for Cas9 it is 20*X + NGG:              XXXXXXXXXXXXXXXXXXXXNGG\n\nforward  - If false will not match to the forward reference strand.\n\nreverse  - If false will not match to the reverse reference strand.\n\ndistance - How many extra nucleotides are needed for a search? This              will indicate within what distance we can search for off-targets.              When we don't have those bases we use DNA_Gap.\n\nextend5  - Defines how off-targets will be aligned to the guides and where              extra nucleotides will be added for alignment within distance. Whether              to extend in the 5' and 3' direction. Cas9 is extend5 = true.\n\nambig_max- How many ambiguous bases are allowed in the pattern?\n\nExample for Cas9 where we want to search for off-targets within distance of 4:\n  alias:    Cas9\n  fwdmotif: NNNNNNNNNNNNNNNNNNNNXXX\n  fwdpam:   XXXXXXXXXXXXXXXXXXXXNGG\n  forward:  true\n  reverse:  true\n  distance: 4\n  extend5:  true\n  ambig_max:5 \n\nAlignments will be performed from opposite to the extension direction (which is defined by extend5).\n\nExamples\n\njulia> Motif(\"Cas9\")\nAlias: Cas9\nMaximum search distance: 4\nNumber of allowed ambigous bp: 0\n20N-NGG\n\njulia> Motif(\"test name\", \"NNNNNNNNNNNNNNNNNNNNXXX\", \"XXXXXXXXXXXXXXXXXXXXNGG\", true, true, 4, true, 5)\nAlias: test name\nMaximum search distance: 4\nNumber of allowed ambigous bp: 5\n20N-NGG\n\n\n\n\n\n","category":"type"},{"location":"abstract_gRNA/#CHOPOFF.length_noPAM","page":"Abstract gRNA","title":"CHOPOFF.length_noPAM","text":"length_noPAM(motif::Motif)\n\nCalculate what is the length of the motif, without extension, and without PAM. Effectively, size of the gRNA.\n\nExamples\n\njulia> length_noPAM(Motif(\"Cas9\"))\n20\n\n\n\n\n\n","category":"function"},{"location":"abstract_gRNA/#CHOPOFF.setdist","page":"Abstract gRNA","title":"CHOPOFF.setdist","text":"setdist(motif::Motif, distance::Int)\n\nSet the distance (maximum value of allowed mismatches, deletion, insertions)  that are allowed during alignment.\n\nExamples\n\njulia> setdist(Motif(\"Cas9\"), 2)\nAlias: Cas9\nMaximum search distance: 2\nNumber of allowed ambigous bp: 0\n20N-NGG\n\n\n\n\n\n","category":"function"},{"location":"abstract_gRNA/#CHOPOFF.setambig","page":"Abstract gRNA","title":"CHOPOFF.setambig","text":"setambig(motif::Motif, ambig::Int)\n\nSet the ambiguity (how many ambiguous bases are allowed, not counting PAM, not counting extension) level for motif.\n\nExamples\n\njulia> setambig(Motif(\"Cas9\"), 15)\nAlias: Cas9\nMaximum search distance: 4\nNumber of allowed ambigous bp: 15\n20N-NGG\n\n\n\n\n\n","category":"function"},{"location":"align_gRNA/","page":"Align gRNA and off-target","title":"Align gRNA and off-target","text":"CollapsedDocStrings = true","category":"page"},{"location":"align_gRNA/#Align-gRNA-and-off-target","page":"Align gRNA and off-target","title":"Align gRNA and off-target","text":"","category":"section"},{"location":"align_gRNA/","page":"Align gRNA and off-target","title":"Align gRNA and off-target","text":"isinclusive\nhamming\nlevenshtein\nAln\nalign","category":"page"},{"location":"align_gRNA/#CHOPOFF.isinclusive","page":"Align gRNA and off-target","title":"CHOPOFF.isinclusive","text":"isinclusive(x::S, y::S) where {S<:BioSymbol}\n\nCheck whether x contains all options of y or y contains all options of x. Can be used as replacement in place of BioSequences.iscompatible or BioSequences.isequal.\n\nExamples\n\njulia> isinclusive(DNA_N, DNA_A)\ntrue\n\njulia> isinclusive(DNA_W, DNA_R) # W is (A/T), R is (A/G)\nfalse\n\njulia> isinclusive(DNA_W, DNA_A)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"align_gRNA/#CHOPOFF.hamming","page":"Align gRNA and off-target","title":"CHOPOFF.hamming","text":"hamming(s1::T, s2::K, ismatch = iscompatible) where {T <: BioSequence, K <: BioSequence}\n\nCheck Hamming distance between s1 and s2 using as matching definition ismatch. Should be faster than pairalign(HammingDistance(), s1, s2). Make sure inputs are of the  same length.\n\nExamples\n\njulia> hamming(dna\"ACGC\", dna\"AWRC\")\n1\n\n\n\n\n\n","category":"function"},{"location":"align_gRNA/#CHOPOFF.levenshtein","page":"Align gRNA and off-target","title":"CHOPOFF.levenshtein","text":"levenshtein(guide::T, ref::K, k::Int = 4,\n    ismatch::Function = iscompatible) where {T <: BioSequence, K <: BioSequence}\n\nCalculate Levenshtein distance bounded by k maximum edit distance with a twist for guide + off-target comparisons.\n\nLevenshtein distance is the minimum number of operations (consisting of insertions, deletions, substitutions of a single character) required to change one string into the other. guide input sequence is a gRNA sequence, ref input is reference sequence with expansion on the 3' end of k bases. This extension will not count toward the score, if it is not covered with aligned guide. Return k + 1, if distance is higher than k and terminate early. This function should be 10x faster than pairalign(LevenshteinDistance(), guide, ref, distance_only = true).\n\nNotice that guide and ref have to be oriented towards left side e.g. PAM-guide, and PAM-offtarget-extension! Take a look at the examples below to understand why.\n\nExamples\n\njulia> levenshtein(dna\"ATGA\", dna\"AGACCT\") # CCT as extension of the ref does not count towards the score in optimal alignment\n1\n\njulia> levenshtein(dna\"ATGATCG\", dna\"AGAAATCGATG\") # ATG does not count in optimal alignment ATG--ATCG/A-GAAATCG\n3\n\n\n\n\n\n","category":"function"},{"location":"align_gRNA/#CHOPOFF.Aln","page":"Align gRNA and off-target","title":"CHOPOFF.Aln","text":"struct Aln\n    guide::String\n    ref::String\n    dist::Int\nend\n\nSimple data structure to hold information on the optimal alignment. Therefore guide and ref may contain DNA_Gap as these are aligned sequences. Function align returns this object.\n\n\n\n\n\n","category":"type"},{"location":"align_gRNA/#CHOPOFF.align","page":"Align gRNA and off-target","title":"CHOPOFF.align","text":"align(guide::T, ref::K, k::Int = 4,\n    ismatch::Function = iscompatible) where {T <: BioSequence, K <: BioSequence}\n\nCalculate Levenshtein distance bounded by k maximum edit distance with a twist for guide + off-target comparisons, but return also the alignment as an Align object.\n\nLevenshtein distance is the minimum number of operations (consisting of insertions, deletions, substitutions of a single character) required to change one string into the other. guide input sequence is a gRNA sequence, ref input is reference sequence with expansion on the 3' end of k bases. This extension will not count toward the score, if it is not covered with aligned guide. Return k + 1, if distance is higher than k and terminate early.\n\nNotice that guide and ref have to be oriented towards left side e.g. PAM-guide, and PAM-offtarget-extension! Take a look at the examples below to understand why.\n\nExamples\n\njulia> align(dna\"ATGA\", dna\"AGACCT\") # CCT as extension of the ref does not count towards the score in optimal alignment\nAln(\"ATGA\", \"A-GA\", 1)\n\njulia> align(dna\"ATGATCG\", dna\"AGAAATCGATG\") # ATG does not count\nAln(\"ATG--ATCG\", \"A-GAAATCG\", 3)\n\n\n\n\n\n","category":"function"},{"location":"find_ot/","page":"Find all off-targets","title":"Find all off-targets","text":"CollapsedDocStrings = true","category":"page"},{"location":"find_ot/#Find-all-off-targets","page":"Find all off-targets","title":"Find all off-targets","text":"","category":"section"},{"location":"find_ot/#Fastest-method-with-symbolic-alignments-and-prefix-hashes","page":"Find all off-targets","title":"Fastest method with symbolic alignments and prefix hashes","text":"","category":"section"},{"location":"find_ot/","page":"Find all off-targets","title":"Find all off-targets","text":"build_prefixHashDB\nsearch_prefixHashDB","category":"page"},{"location":"find_ot/#CHOPOFF.build_prefixHashDB","page":"Find all off-targets","title":"CHOPOFF.build_prefixHashDB","text":"name::String,\n    genomepath::String,\n    motif::Motif,\n    storage_dir::String,\n    hash_len::Int = min(length_noPAM(motif) - motif.distance, 16);\n    reuse_saved::Bool = true)\n\nPrepare prefixHashDB index for future searches using search_prefixHashDB.\n\nWill return a path to the database location, same as storage_dir. If interested with searches within distance 4, preferably use prefix_len of 8 or 9. You can also play with hash_len parameter, but keeping it at 16 should be close to optimal.\n\nArguments\n\nname - Your preferred name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_dir  - Folder path to the where index will be saved with name linearDB.bin and many prefix files.\n\nhash_len - Length of the hash in bp. At maximum 16.\n\nreuse_saved - Whether to reuse paths that were saved for Cas9 distance 4 and prefix 16.\n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"prefixHashDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a prefixHashDB\nbuild_prefixHashDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"prefixHashDB\", \"results.csv\")\nsearch_prefixHashDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.search_prefixHashDB","page":"Find all off-targets","title":"CHOPOFF.search_prefixHashDB","text":"search_prefixHashDB(\n    storage_dir::String, \n    guides::Vector{LongDNA{4}}, \n    output_file::String;\n    distance::Int = 3,\n    early_stopping::Vector{Int} = Int.(floor.(exp.(0:distance))))\n\nFind all off-targets for guides within distance of dist using prefixHashDB located at storage_dir. Uses early stopping to stop searching when a guide passes a limit on number of off-targets. This method does not  keep track of the off-target locations and does not filter overlapping off-targets, therefore it might hit the  early stopping condition a little earlier than intended.\n\nAssumes your guides do not contain PAM, and are all in the same direction as  you would order for the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n    \n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\noutput_file - Path and name for the output file, this will be comma separated table, therefore .csv extension is preferred.  This search will create intermediate files which will have same name as output_file, but with a sequence prefix. Final file will contain all those intermediate files.\n\ndistance - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.\n\nearly_stopping - Integer vector. Early stopping condition. For example for distance 2, we need vector with 3 values e.g. [1, 1, 5]. Which means we will search with \"up to 1 offtargets within distance 0\", \"up to 1 offtargets within distance 1\"...\n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"prefixHashDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a prefixHashDB\nbuild_prefixHashDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"prefixHashDB\", \"results.csv\")\nsearch_prefixHashDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#Prefix-Suffix-partial-alignment","page":"Find all off-targets","title":"Prefix-Suffix partial alignment","text":"","category":"section"},{"location":"find_ot/","page":"Find all off-targets","title":"Find all off-targets","text":"build_linearDB\nsearch_linearDB\n\nbuild_motifDB\nsearch_motifDB","category":"page"},{"location":"find_ot/#CHOPOFF.build_linearDB","page":"Find all off-targets","title":"CHOPOFF.build_linearDB","text":"build_linearDB(\n    name::String,\n    genomepath::String,\n    motif::Motif,\n    storage_dir::String,\n    prefix_len::Int = 7)\n\nPrepare linearDB index for future searches using search_linearDB.\n\nWill return a path to the database location, same as storage_dir. When this database is used for the guide off-target scan it is similar  to linear in performance, hence the name. There is an optimization that  if the alignment becomes impossible against the prefix we don't search the off-targets grouped inside the prefix. Therefore, it is advantageous to select much larger prefix than maximum  search distance, however in that case number of files also grows. For example, if interested with searches within distance 4, preferably use prefix length of  7 or 8.\n\nArguments\n\nname - Your preferred name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_dir  - Folder path to the where index will be saved with name linearDB.bin and many prefix files.\n\nprefix_len  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files.\n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"linearDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a linearDB\nbuild_linearDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"linearDB\", \"results.csv\")\nsearch_linearDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.search_linearDB","page":"Find all off-targets","title":"CHOPOFF.search_linearDB","text":"search_linearDB(\n    storage_dir::String, \n    guides::Vector{LongDNA{4}}, \n    output_file::String;\n    distance::Int = 4)\n\nFind all off-targets for guides within distance of dist using linearDB located at storage_dir.\n\nAssumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n    \n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\noutput_file - Path and name for the output file, this will be comma separated table, therefore .csv extension is preferred.  This search will create intermediate files which will have same name as output_file, but with a sequence prefix. Final file will contain all those intermediate files.\n\ndistance - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.\n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"linearDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a linearDB\nbuild_linearDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"linearDB\", \"results.csv\")\nsearch_linearDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.build_motifDB","page":"Find all off-targets","title":"CHOPOFF.build_motifDB","text":"build_motifDB(\n    name::String,\n    genomepath::String,\n    motif::Motif,\n    storage_dir::String,\n    prefix_len::Int = 7;\n    skipmer_size::Int = Int(floor(length_noPAM(motif) / (motif.distance + 3))))\n\nPrepare motifDB index for future searches using search_motifDB.\n\nWill return a path to the database location, same as storage_dir. When this database is used for the guide off-target scan it is similar  to search_linearDB, however additional filter is applied on top of  prefix filtering. Suffixes are used for next filter, similarly to  pigeon hole principle - depending on the size of the skipmer skipmer_size. For example, Cas9 off-target within distance 4 (d) might be 20bp long. We skip prefix_len of 7, and are left with 13bp which can be split into 3  skipmer (r) of size 4, 1bp will be left unused. However when searching within  distance of 4 and for prefix where initial alignment was of distance 3 (m) and adjustment parameter is 0 (a). We are obliged to find at least r - (d - m + a)  which is 3 - (4 - 3 + 0) = 2 this many skipmers inside the off-targets. \n\nThere exist also another approach which builds on the idea that it might be more efficient to find at least two kmers of smaller size (named 01*0 seed) rather than one larger kmer  (pigeon hole principle). You can use the adjust option for that during search_linearDB step.\n\nBe sure to understand implications of using motifDB as using wrong parameters  on skipmer_size might result in leaky filtering in relation to the assumed  distance dist and adjustment adjust during search step in search_motifDB.\n\nArguments\n\nname - Your preferred name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_dir  - Folder path to the where index will be saved and many prefix files.\n\nprefix_len  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files. \n\nskipmer_size - Size of the skipmer as described above. Be careful when setting this too large!\n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"motifDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a motifDB\nbuild_motifDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"motifDB\", \"results.csv\")\nsearch_motifDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.search_motifDB","page":"Find all off-targets","title":"CHOPOFF.search_motifDB","text":"search_motifDB(\n    storage_dir::String, \n    guides::Vector{LongDNA{4}}, \n    output_file::String;\n    distance::Int = 3,\n    adjust::Int = 0)\n\nFind all off-targets for guides within distance of distance using motifDB located at storage_dir.\n\nAssumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n    \n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\nstorage_dir - Directory containing motifDB.\n\nguides - a vector of gRNAs without PAM.\n\noutput_file - File to which write detailed results. This search will create intermediate  files which will have same name as output_file, but with a sequence prefix. Final file will contain all those intermediate files, and other files with sequence prefix will be deleted.\n\ndistance - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.  \n\nadjust - This will be crucial parameter for tightening second layer of filtering after,  the initial prefix alignment. For example, Cas9 off-target within distance 4 (d) might be 20bp long. We skip prefix_len of 7, and are left with 13bp which can be split into 3 skipmers (r) of size 4,  1bp will be left unused. However when searching within distance of 4 and for prefix where initial  alignment was of distance 3 (m) and adjustment parameter is 0 (a). We are obliged to find at least  r - (d - m + a) which is 3 - (4 - 3 + 0) = 2 this many skipmers inside the off-targets. \n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"motifDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a motifDB\nbuild_motifDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"motifDB\", \"results.csv\")\nsearch_motifDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#Vantage-Point-tree","page":"Find all off-targets","title":"Vantage-Point tree","text":"","category":"section"},{"location":"find_ot/","page":"Find all off-targets","title":"Find all off-targets","text":"build_treeDB\ninspect_treeDB\nsearch_treeDB","category":"page"},{"location":"find_ot/#CHOPOFF.build_treeDB","page":"Find all off-targets","title":"CHOPOFF.build_treeDB","text":"build_treeDB(\n    name::String,\n    genomepath::String,\n    motif::Motif,\n    storage_dir::String,\n    prefix_len::Int = 7)\n\nBuild a Vantage Point tree DB of offtargets for the given motif, DB groups off-targets by their prefixes, each prefix has its own Vantage Point tree.\n\nWill return a path to the database location, same as storage_dir.\n\nThere is an optimization that if the alignment becomes impossible against the prefix we don't search the off-targets grouped inside the prefix. Therefore it is advantageous to select larger prefix than maximum  search distance, however in that case number of files also grows.\n\nArguments\n\nname - Your preferred name for this index for easier identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_dir  - Folder path to the where index will be saved with name linearDB.bin and many prefix files.\n\nprefix_len  - Size of the prefix by which off-targets are indexed. Prefix of 8 or larger will be the fastest,                 however it will also result in large number of files. \n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"treeDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a treeDB\nbuild_treeDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"treeDB\", \"results.csv\")\nsearch_treeDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.inspect_treeDB","page":"Find all off-targets","title":"CHOPOFF.inspect_treeDB","text":"inspect_treeDB(\n    storage_dir::String; \n    levels::Int = 5, \n    inspect_prefix::String = \"\")\n\nSee small part of the full vantage point tree of the treeDB.\n\nTreeDB can be split based on the distance to the radius (r)  into inside (left <= r) and right (outside > r) nodes.\n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"treeDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a treeDB\nbuild_treeDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"treeDB\", \"results.csv\")\nsearch_treeDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n# finally, view some part of the database!\ninspect_treeDB(db_path; inspect_prefix = \"CCGTCGC\")\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.search_treeDB","page":"Find all off-targets","title":"CHOPOFF.search_treeDB","text":"search_treeDB(\n    storage_dir::String, \n    guides::Vector{LongDNA{4}}, \n    output_file::String;\n    distance::Int = 3)\n\nSearch previously build treeDB database for the off-targets of the guides. \n\nAssumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n\n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\ndist - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.  \n\ndetail - Path and name for the output file. This search will create intermediate  files which will have same name as detail, but with a sequence prefix. Final file will contain all those intermediate files. Leave detail empty if you are only  interested in off-target counts returned by the treeDB. \n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"treeDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a treeDB\nbuild_treeDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"treeDB\", \"results.csv\")\nsearch_treeDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#Experiments-with-FM-index","page":"Find all off-targets","title":"Experiments with FM-index","text":"","category":"section"},{"location":"find_ot/","page":"Find all off-targets","title":"Find all off-targets","text":"build_PathTemplates\nbuild_fmiDB\nsearch_fmiDB\n\nbuild_pamDB\nsearch_fmiDB_seed\n\nbuild_binaryFuseFilterDB\nsearch_binaryFuseFilterDB","category":"page"},{"location":"find_ot/#CHOPOFF.build_PathTemplates","page":"Find all off-targets","title":"CHOPOFF.build_PathTemplates","text":"build_PathTemplates(\n    motif::Motif; \n    storagepath::String = \"\", \n    mismatch_only::Bool = false, \n    restrict_to_len::Int = length_noPAM(motif),\n    withPAM::Bool = false)\n\nBuilds up a PathTemplates object. Stores  shortened version of all possible paths within each distance d mapped on the graph of all possible alignments of sequence of length len. Then one can use templates_to_sequences_extended or  templates_to_sequences and map guide sequence to all possible alignments quickly.\n\nArguments\n\nlen - length of the sequence (e.g. guide - without PAM)\n\nd - Maximal distance on which to build the graph.\n\nstoragepath - If not empty \"\", will save the object under given path.\n\nmismatch_only - Whether to skip insertions/deletions.\n\nrestrict_to_len - To which length ambiguity should be expanded and after which length ambiguity should be collapsed if possible.     For example: ACTG and ANNN with restriction to length 2, would result in these seqeunces: ACNN AANN AGNN ATNN     This length does not includes PAM - it applies directly to the guide seqeunce. The default is full length of the guide and its maximal distance.\n\nwithPAM - Whether to include PAM in the paths. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.build_fmiDB","page":"Find all off-targets","title":"CHOPOFF.build_fmiDB","text":"build_fmiDB(\n    genomepath::String,\n    storage_dir::String)\n\nPrepare FM-index for future searches.\n\nArguments\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nstorage_dir  - Path to the DIRECTORY where index with many files will be saved.\n\nExamples\n\n# prepare libs\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\nfmi_dir = joinpath(tdir, \"fmi\")\nmkpath(fmi_dir)\n\n# use CHOPOFF example genome\ngenome = joinpath(vcat(splitpath(dirname(pathof(CHOPOFF)))[1:end-1], \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a fmiDB!\nbuild_fmiDB(genome, fmi_dir)\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.search_fmiDB","page":"Find all off-targets","title":"CHOPOFF.search_fmiDB","text":"search_fmiDB(\n    guides::Vector{LongDNA{4}}, \n    mpt::PathTemplates, \n    motif::Motif, \n    fmidbdir::String,\n    output_file::String; \n    distance::Int = 2)\n\nSearch FM-index for off-targets using brute-force enumeration method.\n\nExperimental! Proof-of-concept!\n\nThis method uses PathTemplates build on top of Motif to enumerate all possible off-target sequences, next, these sequences are found in the genome using FM-index. This method is impractically slow above distance of 2.\n\nArguments\n\nguides - a vector of gRNAs without PAM.\n\nmpt - PathTemplates object that contains abstraction for all possible alignments\n\nmotif - Motif defines what kind of gRNA to search for. Has to be compatible with mpt.\n\nfmidbdir   - Path to the folder where FM-index was build using build_fmi.\n\noutput_file  - Where output will be saved.\n\ndistance  - Search distance, maximum of 2 is practical.\n\nExamples\n\n# prepare libs\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\nfmi_dir = joinpath(tdir, \"fmi\")\nmkpath(fmi_dir)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# build FM-index\nbuild_fmiDB(genome, fmi_dir)\nmotif = Motif(\"Cas9\"; distance = 1)\nmpt = build_PathTemplates(motif; withPAM = true) # its important to add PAM here!\n\n# prepare output folder\nres_dir = joinpath(tdir, \"results\")\nmkpath(res_dir)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(res_dir, \"results.csv\")\nsearch_fmiDB(guides, mpt, fmi_dir, res_path; distance = 1)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 1)\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.build_pamDB","page":"Find all off-targets","title":"CHOPOFF.build_pamDB","text":"build_pamDB(\n    fmidbdir::String, \n    motif::Motif; \n    storage_path::String = \"\")\n\nFind locations of all the PAM for a given motif in the genome.\n\nExample of what position we store for traditional Cas9 (NGG, CCN) and Cas12a (TTTV, BAAA):\n\nNGG  CCN TTTN  NAAA\n^      ^    ^  ^\n\nArguments\n\nfmidbdir - Path to directory with the FM-index build with build_fmiDB.\n\nmotif - Motif defines which PAM we will locate in the genome.\n\nstorage_path  - Path to the DIRECTORY where index will be saved.\n\nExamples\n\n# prepare libs\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\nfmi_dir = joinpath(tdir, \"fmi\")\nmkpath(fmi_dir)\n\n# use CHOPOFF example genome\ngenome = joinpath(\n    vcat(\n        splitpath(dirname(pathof(CHOPOFF)))[1:end-1], \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# build FM-index\nbuild_fmiDB(genome, fmi_dir)\n\n# build a pamDB\npamDB = build_pamDB(fmi_dir, Motif(\"Cas9\"))\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.search_fmiDB_seed","page":"Find all off-targets","title":"CHOPOFF.search_fmiDB_seed","text":"search_fmiDB_seed(\n    guides::Vector{LongDNA{4}},\n    fmidbdir::String, \n    genomepath::String, \n    pamDB::PAMinFMI,\n    output_file::String; \n    distance::Int = 2)\n\nSearch FM-index for off-targets using 01*0 seed method.  Read more here: publication  and pdf.\n\nExperimental! Proof-of-concept!\n\nArguments\n\nguides - a vector of gRNAs without PAM.\n\nfmidbdir   - Path to the folder where FM-index was build using build_fmi.\n\ngenomepath - Path to the genome used to build the FM-index.\n\npamDB - object build with build_pamDB that contains locations of the PAM inside the genome.\n\noutput_file  - Where output will be saved.\n\ndistance  - Search distance, maximum of 2 is practical.\n\nExamples\n\n# prepare libs\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\nfmi_dir = joinpath(tdir, \"fmi\")\nmkpath(fmi_dir)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# build FM-index\nbuild_fmiDB(genome, fmi_dir)\n\n# build a pamDB\nmotif = Motif(\"Cas9\"; distance = 1)\npamDB = build_pamDB(fmi_dir, motif)\n\n# prepare PathTemplates\nmpt = build_PathTemplates(motif)\n\n# prepare output folder\nres_dir = joinpath(tdir, \"results\")\nmkpath(res_dir)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(res_dir, \"results.csv\")\nsearch_fmiDB_seed(guides, fmi_dir, genome, pamDB, res_path; distance = 1)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 1)\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.build_binaryFuseFilterDB","page":"Find all off-targets","title":"CHOPOFF.build_binaryFuseFilterDB","text":"build_binaryFuseFilterDB(\n    name::String, \n    genomepath::String, \n    motif::Motif,\n    storage_dir::String;\n    seed::UInt64 = UInt64(0x726b2b9d438b9d4d),\n    max_iterations::Int = 10,\n    precision::DataType = UInt32)\n\nPrepare hashDB index for future searches using search_hashDB.\n\nArguments\n\nname - Your preferred name for this index to ease future identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for and at what maxium distance.\n\nstorage_dir  - Directory to the where many files needed by the database will be saved. Naming                   of the files follows this pattern:                   BinaryFuseFilterDB_ + chromsome + .bin                  Each unique motif has its own file naming created.\n\nseed  - Optional. Seed is used during hashing for randomization.\n\nmax_iterations - When finding hashing structure for binary fuse filter it might fail sometimes,                     we will retry max_iterations number of times though.\n\nprecision- The higher the precision the larger the database, but also chances for error decrease dramatically.              We support UInt8, UInt16, and UInt32.\n\nrestrict_to_len - Restrict lengths of the motif for the purpose of checking its presence in the genome.                     Allows for significant speedups when expanding all possible sequences for each guide, as we will expand                     up to the specified length here. For example, default setting for Cas9, would restrict standard 20bp to                     16bp for the genome presence check, for distance of 4 that would be 8 bases (4bp from the 20 - 16, and 4                      bases because of the potential extension) that have to be actually aligned in the genome.\n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"binaryFuseFilterDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a binaryFuseFilterDB\nbuild_binaryFuseFilterDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"binaryFuseFilterDB\", \"results.csv\")\nsearch_binaryFuseFilterDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.search_binaryFuseFilterDB","page":"Find all off-targets","title":"CHOPOFF.search_binaryFuseFilterDB","text":"search_binaryFuseFilterDB(\n    bffddbir::String, \n    fmidbdir::String,\n    genomepath::String, \n    guides::Vector{LongDNA{4}}, \n    output_file::String;\n    distance::Int = 0)\n\nFind all off-targets for guides within distance of dist using BinaryFuseFilterDB located at storage_dir.\n\nAssumes your guides do not contain PAM, and are all in the same direction as  you would order from the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n    \n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\nbffdbdir - Folder location where BinaryFuseFilterDB is stored at.\n\nfmidbdir - Folder location where FM-index is build.\n\nguides - Vector of your guides, without PAM.\n\noutput_file - Path and name for the output file, this will be comma separated table, therefore .csv extension is preferred.  This search will create intermediate files which will have same name as output_file, but with a sequence prefix. Final file will contain all those intermediate files.\n\ndistance - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.\n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"binaryFuseFilterDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a binaryFuseFilterDB\nbuild_binaryFuseFilterDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"binaryFuseFilterDB\", \"results.csv\")\nsearch_binaryFuseFilterDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#VCF","page":"Find all off-targets","title":"VCF","text":"","category":"section"},{"location":"find_ot/","page":"Find all off-targets","title":"Find all off-targets","text":"build_vcfDB\nsearch_vcfDB","category":"page"},{"location":"find_ot/#CHOPOFF.build_vcfDB","page":"Find all off-targets","title":"CHOPOFF.build_vcfDB","text":"build_vcfDB(\n    name::String, \n    genomepath::String, \n    vcfpath::String,\n    motif::Motif,\n    storage_path::String,\n    hash_len::Int = min(length_noPAM(motif) - motif.distance, 16);\n    reuse_saved::Bool = true,\n    variant_overlaps = true)\n\nBuilds a database of all potential off-targets that overlap any of the variants in the VCF file. It supports combinations of variants that are close to each other, will report all possible combinations of  variants. This database uses simialr principles to prefixHashDB, also utilizes hashed prefix of specific length. In case of troubles with loading of VCF files, the only fields that we use are ID, CHROM, POS, REF, ALT, so its  often possible to remove INFO field and other unnecesary fields which may cause troubles.\n\nArguments\n\nname - Your preferred name for this index for future identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nvcfpath - Path to the VCF file, it has to be compatible with your genome.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_path  - Path to the where index will be saved. Normally, it includes \".bin\" extension.\n\nhash_len - length of the prefix that is stored inside the hash\n\nreuse_saved - Whether to reuse paths that were saved for Cas9 distance 4 and prefix 16.\n\nvariant_overlaps - Whether to check for all potential combinations of alternate alleles for nearby variants.     Only use with small VCF files! Preferably only run for specific variants.\n\nExamples\n\n# prepare libs\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"vcfDB.bin\")\n\n# use CHOPOFF example genome and vcf file\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\nvcf = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"artificial.vcf\"))\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n\n# example VCF file\nbuild_vcfDB(\n    \"samirandom\", genome, vcf,\n    Motif(\"Cas9\"; distance = 2, ambig_max = 3),\n    db_path)\n\n# search using vcfDB\noutput_file = joinpath(tdir, \"output.csv\")\nsearch_vcfDB(db_path, guides, output_file)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(output_file))\n\n\n\n\n\n\n","category":"function"},{"location":"find_ot/#CHOPOFF.search_vcfDB","page":"Find all off-targets","title":"CHOPOFF.search_vcfDB","text":"search_vcfDB(\n    storage_path::String, \n    guides::Vector{LongDNA{4}}, \n    output_file::String;\n    distance::Int = 3,\n    early_stopping::Vector{Int} = Int.(floor.(exp.(0:distance))))\n\nFind all off-targets for guides within distance of dist using vcfDB located at storage_dir. Uses early stopping to stop searching when a guide passes a limit on number of off-targets. This method does not  keep track of the off-target locations and does not filter overlapping off-targets, therefore it might hit the  early stopping condition a little earlier than intended. Especially, when variants have multiple ALT and  multiple variants are overlapping off-targets, this function will report each combination of the overlapping variants. Each of these combinations will also count towards early stopping condition.\n\nAssumes that your guides do not contain PAM, and are all in the same direction as  you would order for the lab e.g.:\n\n5' - ...ACGTCATCG NGG - 3'  -> will be input: ...ACGTCATCG\n     guide        PAM\n    \n3' - CCN GGGCATGCT... - 5'  -> will be input: ...AGCATGCCC\n     PAM guide\n\nArguments\n\noutput_file - Path and name for the output file, this will be comma separated table, therefore .csv extension is preferred.  This search will create intermediate files which will have same name as output_file, but with a sequence prefix. Final file will contain all those intermediate files.\n\ndistance - Defines maximum levenshtein distance (insertions, deletions, mismatches) for  which off-targets are considered.\n\nearly_stopping - Integer vector. Early stopping condition. For example for distance 2, we need vector with 3 values e.g. [1, 1, 5]. Which means we will search with \"up to 1 offtargets within distance 0\", \"up to 1 offtargets within distance 1\"...\n\nExamples\n\n# prepare libs\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"vcfDB.bin\")\n\n# use CHOPOFF example genome and vcf file\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\nvcf = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"artificial.vcf\"))\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n\n# example VCF file\nbuild_vcfDB(\n    \"samirandom\", genome, vcf,\n    Motif(\"Cas9\"; distance = 2, ambig_max = 3),\n    db_path)\n\n# search using vcfDB\noutput_file = joinpath(tdir, \"output.csv\")\nsearch_vcfDB(db_path, guides, output_file)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(output_file))\n\n\n\n\n\n\n","category":"function"},{"location":"alignment_free/","page":"Alignment-free filters for gRNAs","title":"Alignment-free filters for gRNAs","text":"CollapsedDocStrings = true","category":"page"},{"location":"alignment_free/#Alignment-free-filters-for-gRNAs","page":"Alignment-free filters for gRNAs","title":"Alignment-free filters for gRNAs","text":"","category":"section"},{"location":"alignment_free/","page":"Alignment-free filters for gRNAs","title":"Alignment-free filters for gRNAs","text":"build_hashDB\nsearch_hashDB\nbuild_dictDB\nsearch_dictDB","category":"page"},{"location":"alignment_free/#CHOPOFF.build_hashDB","page":"Alignment-free filters for gRNAs","title":"CHOPOFF.build_hashDB","text":"build_hashDB(\n    name::String, \n    genomepath::String, \n    motif::Motif;\n    storage_path::String = \"\",\n    seed::UInt64 = UInt64(0x726b2b9d438b9d4d),\n    max_iterations::Int = 10,\n    max_count::Int = 10,\n    precision::DataType = UInt16)\n\nPrepare hashDB index for future searches using search_hashDB.\n\nArguments\n\nname - Your preferred name for this index to ease future identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_path  - Path to the where index will be saved.\n\nseed  - Optional. Seed is used during hashing for randomization.\n\nmax_iterations - When finding hashing structure for binary fuse filter it might fail sometimes,                     we will retry max_iterations number of times though.\n\nmax_count  - Above this count we put all unique off-targets into one bin.                 Put number here that is the minimum number of off-targets that you think is fine                for the distance of 1.\n\nprecision- The higher the precision the larger the database, but also chances for error decrease dramatically.              We support UInt8, UInt16, and UInt32.\n\nExamples\n\n# prepare libs\nusing CHOPOFF, BioSequences\n\n# use CHOPOFF example genome\ngenome = joinpath(\n    vcat(splitpath(dirname(pathof(CHOPOFF)))[1:end-1], \n    test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# finally, build a hashDB\nbuild_hashDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 1, ambig_max = 0))\n\n\n\n\n\n","category":"function"},{"location":"alignment_free/#CHOPOFF.search_hashDB","page":"Alignment-free filters for gRNAs","title":"CHOPOFF.search_hashDB","text":"search_hashDB(\n    db::HashDB,\n    guides::Vector{LongDNA{4}},\n    right::Bool)\n\nEstimate off-target counts for guides using hashDB stored at storage_dir.\n\nProbabilistic filter offers a guarantee that it will always be correct when a sequence  is in the set (no false negatives), but may overestimate that a sequence is in the set  while it is not (false positive) with low probability. If both columns in the results are 0,  it is guaranteed this gRNA has no off-targets in the genome!\n\nAlso, maximum count for each off-target in the database is capped, to max_count specified during building of hashDB. This means  that counts larger than max_count are no longer estimating correctly. Its likely you would not care for those guides anyhow.\n\nright argument specifies whether the database should be checked in direction from  unique off-targets which occur once to increasingly more occurring off-targets up until  max_count is reached, which may result in assuming lower than real off-target counts  (underestimate) for some of the sequences, however this approach will not reject any  gRNAs that should not be rejected and is suitable for filtering of gRNAs we do not need.  Left (right = false, or hight-counts to low-counts) approach is also supported,  which can be used for ordering of gRNAs to the best of database ability.  Left approach may overestimate counts for some gRNAs. When gRNA is reported as  off-target free it is also guaranteed to be true in both cases (low-to-high and high-to-low).\n\nExamples\n\n# prepare libs\nusing CHOPOFF, BioSequences\n\n# use CHOPOFF example genome\nCHOPOFF_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(CHOPOFF_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a hashDB\ndb = build_hashDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 1, ambig_max = 0))\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(CHOPOFF_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n\n# finally, get results!\nhdb_res = search_hashDB(db, guides, false)\n\n\n\n\n\n","category":"function"},{"location":"alignment_free/#CHOPOFF.build_dictDB","page":"Alignment-free filters for gRNAs","title":"CHOPOFF.build_dictDB","text":"build_dictDB(\n    name::String, \n    genomepath::String, \n    motif::Motif;\n    storage_path::String = \"\")\n\nPrepare dictDB index for future searches using search_dictDB.\n\nArguments\n\nname - Your preferred name for this index to ease future identification.\n\ngenomepath - Path to the genome file, it can either be fasta or 2bit file. In case of fasta                also prepare fasta index file with \".fai\" extension.\n\nmotif   - Motif defines what kind of gRNA to search for.\n\nstorage_path  - Path to the where index will be saved.\n\nExamples\n\n# prepare libs\nusing CHOPOFF, BioSequences\n\n# use CHOPOFF example genome\ngenome = joinpath(vcat(splitpath(dirname(pathof(CHOPOFF)))[1:end-1], \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a hashDB!\ndb = build_dictDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 1, ambig_max = 0))\n\n\n\n\n\n","category":"function"},{"location":"alignment_free/#CHOPOFF.search_dictDB","page":"Alignment-free filters for gRNAs","title":"CHOPOFF.search_dictDB","text":"search_dictDB(\n    db::DictDB,\n    guides::Vector{LongDNA{4}})\n\nSummarize off-target counts for guides using dictDB.\n\nThis is simple dictionary storing all possible off-targets and their counts for a given Motif. If you find no off-targets using this method it is guaranteed this gRNA has no off-targets in the genome! Beware that the dictionary can be very big (e.g. human genome ~ 8Gb).\n\nExamples\n\n# prepare libs\nusing CHOPOFF, BioSequences\n\n# use CHOPOFF example genome\nCHOPOFF_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(CHOPOFF_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a dictDB\ndb = build_dictDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"; distance = 1, ambig_max = 0))\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(CHOPOFF_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n\n# finally, get results!\nres = search_dictDB(db, guides)\n\n\n\n\n\n","category":"function"},{"location":"find_potential_ot/","page":"Find potential off-targets","title":"Find potential off-targets","text":"CollapsedDocStrings = true","category":"page"},{"location":"find_potential_ot/#Find-potential-off-targets","page":"Find potential off-targets","title":"Find potential off-targets","text":"","category":"section"},{"location":"find_potential_ot/","page":"Find potential off-targets","title":"Find potential off-targets","text":"DBInfo\ngatherofftargets!","category":"page"},{"location":"find_potential_ot/#CHOPOFF.DBInfo","page":"Find potential off-targets","title":"CHOPOFF.DBInfo","text":"DBInfo(filepath::String, name::String, motif::Motif; vcf_filepath::String = \"\")\n\nMotif defines what genome file is being used for the searches.\n\nArguments\n\nfilepath - Path to the genome file, if file is fasta (ends with .fa or .fasta or .fna)  make sure you also have fasta index file with extension .fai. Alternatively, you can use .2bit  genome file.  \n\nname - Your name for this instance of DBInfo: the genome with connection to the motif and vcf file.\n\nmotif   - Motif object defining search parameters\n\nvcf_filepath  - Optional. Path to the VCF file to include in the searches.\n\nAlignments will be performed from opposite to the extension direction (which is defined by extend5).\n\nExamples\n\n# use CHOPOFF example genome\ngenome = joinpath(vcat(splitpath(dirname(pathof(CHOPOFF)))[1:end-1], \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# construct example DBInfo\nDBInfo(genome, \"Cas9_semirandom_noVCF\", Motif(\"Cas9\"))\n\n\n\n\n\n","category":"type"},{"location":"find_potential_ot/#CHOPOFF.gatherofftargets!","page":"Find potential off-targets","title":"CHOPOFF.gatherofftargets!","text":"function gatherofftargets!(\n    output::T,\n    dbi::DBInfo;\n    remove_pam::Bool = true,\n    normalize::Bool = true,\n    restrict_to_len::Union{Nothing, Int64} = nothing) where {T<:Union{Vector{String}, Vector{UInt64}, Vector{UInt128}}}\n\nGathers all off-targets that conform to the given dbi Motif.\n\nThis function appends to the output during the run, however it will also return all ambiguous  guides in return object. We can use UInt64 and UInt128 to compress space that the gRNAs use. When using  large genomes or non-specific PAMs you might run out of memory when using this function.\n\nremovepam - whether PAM sequence should be removed normalize - whether all guides should be flipped into PAMseqEXT e.g. GGn-20N-3bp restricttolen - will restrict the guides to be of specific lengths, smaller than the initial motif     this includes/excludes PAM based on removepam as remove_pam is applied before the length restriction\n\nExamples\n\n# use CHOPOFF example genome\ngenome = joinpath(\n    vcat(\n        splitpath(dirname(pathof(CHOPOFF)))[1:end-1], \n        \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n# construct example DBInfo\ndbi = DBInfo(genome, \"Cas9_semirandom_noVCF\", Motif(\"Cas9\"))\n# finally gather all off-targets\nguides = Vector{String}()\nambig = gatherofftargets!(guides, dbi)\n\n# here in the format of UInt64 encoding\nguides2 = Vector{UInt64}()\nambig2 = gatherofftargets!(guides2, dbi)\nguide_with_extension_len = length_noPAM(dbi.motif) + dbi.motif.distance\n\n# transform UInt64 to LongDNA and String\nguides2 = String.(LongDNA{4}.(guides2, guide_with_extension_len))\n\n\n\n\n\n","category":"function"},{"location":"#CHOPOFF.jl","page":"General","title":"CHOPOFF.jl","text":"","category":"section"},{"location":"#About","page":"General","title":"About","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Uncompromising finding of CRISPR off-targets:","category":"page"},{"location":"","page":"General","title":"General","text":"many fast alignment algorithms optimized specifically for CRISPR\nsearch for larger distances allowing for mismatches and bulges\nsupport for ambiguous bases\narbitrarily large genomes\nVCF support - with multiple overlapping SNPs\nnear-instant alignment-free off-target filtering\npruning of off-targets by their location (remove overlapping, competing off-targets)\nextensively tested\nfull framework that can be extended for your own algorithms with ease","category":"page"},{"location":"#Requirements","page":"General","title":"Requirements","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Some algorithms generate as many files as there are prefixes (e.g. for prefix 7 - this will make 4^7 - 16384 files). This strategy allows us to operate the searches independently on multiple cores and not get throttled when querying large number of the guides. However, some systems have artificial limits on the number of open files, for example in Ubuntu 'ulimit -n' will show the limit. Increase the limits, if it creates problems for you.\nWhen using many cores for building the indexes - you have to have around ~1 GB of RAM per thread.","category":"page"},{"location":"#Standalone-application","page":"General","title":"Standalone application","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"It is possible to build CHOPOFF into standalone application - which includes all dependencies and Julia into one compiled software. This is recommended method for using of CHOPOFF when you are not a developer. If you know how to code in Julia, you might make use of the whole framework using CHOPOFF as a package.","category":"page"},{"location":"","page":"General","title":"General","text":"To build a standalone application run ./build_standalone.sh script from the main directory. Script will produce binary in a \"build\" folder. Then you can run from inside that folder ./bin/CHOPOFF --help. To learn about building a database run ./bin/CHOPOFF build --help and to use existing database check out ./bin/CHOPOFF search --help. It is possible to skip testing + precompile step to speed up the build process with ./build_standalone.sh --noprecompile.","category":"page"},{"location":"","page":"General","title":"General","text":"You can alternatively download the latest release from the releases' page on the GitHub.","category":"page"},{"location":"","page":"General","title":"General","text":"When using application as self-contained compiled software, you can control number of cores by setting JULIA_NUM_THREADS environment variable.","category":"page"},{"location":"","page":"General","title":"General","text":"Example commands for using standalone","category":"page"},{"location":"","page":"General","title":"General","text":"Building of prefixHashDB database for standard Cas9 --motif with support for up to levenshtein distance 3 --distance for an example genome using 10 threads.","category":"page"},{"location":"","page":"General","title":"General","text":"export JULIA_NUM_THREADS=10  \nEXAMPLE_GENOME=\"./test/sample_data/genome/semirandom.fa\"\nCHOPOFF build --name Cas9_hg38 --genome \"$EXAMPLE_GENOME\" -o out_dir/phDB_16_3/ --distance 3 --motif Cas9 prefixHashDB","category":"page"},{"location":"","page":"General","title":"General","text":"Searching of above database for all off-targets for guides listed in --guides up to the 2 levenshtein distance --distance using 15 threads, writing the results into --output file. Because --early_stopping argument is not supplied below, by default prefixHashDB will search for up to 1e6 off-targets per guide per distance. Pay attention that default guides for the Cas9, are 20bp long, as can be inspected in the example file.","category":"page"},{"location":"","page":"General","title":"General","text":"export JULIA_NUM_THREADS=15  \nEXAMPLE_GUIDES=\"./test/sample_data/guides.txt\"\nCHOPOFF search --database phDB_16_3/ --guides \"$EXAMPLE_GUIDES\" --output out_dir/phDB_16_2.csv --distance 2 prefixHashDB","category":"page"},{"location":"#No-build-application","page":"General","title":"No-build application","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Run CHOPOFF package as an application, without building first. From the directory of the package run:","category":"page"},{"location":"","page":"General","title":"General","text":"julia --threads 4 --project=\".\" ./src/CHOPOFF.jl --help","category":"page"},{"location":"#Quick-Use","page":"General","title":"Quick Use","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"For search of off-targets you have a couple of options:","category":"page"},{"location":"","page":"General","title":"General","text":"prefixHashDB - the fastest, we apply hashes to symbolic alignments for fast filtering of OTs  \nlinearDB - most rigorously tested\nmotifDB - on top of linearDB we apply pigeonhole principle like filter which you can adjust\ntreeDB - will work best for longer gRNAs, uses vantage point for filteirng\nfmiDB - the smallest file size, very fast, but only for distances ≤ 2\nbinaryFuseFilterDB - uses hashing on top of FM-index","category":"page"},{"location":"","page":"General","title":"General","text":"If you would like to filter or rank gRNAs to only those that are most likely off-target free you want to use hashDB or slower and much larger, but less probabilistic dictDB.","category":"page"},{"location":"","page":"General","title":"General","text":"For VCF file support use vcfDB.  For use of the framework as a Julia package consult the documentation - Public Interface section.","category":"page"},{"location":"#Support","page":"General","title":"Support","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"You can buy me a coffee to show some love and appreciation!","category":"page"},{"location":"","page":"General","title":"General","text":"<img src=\"./assets/bmc_qr.png\" width=\"25%\"/>","category":"page"},{"location":"#LICENSE","page":"General","title":"LICENSE","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Copyright © 2022 Kornel Labun","category":"page"},{"location":"","page":"General","title":"General","text":"License for non-commercial applications is aGPL-3.0.  For commercial applications you should acquire permission or licensing contract.","category":"page"},{"location":"","page":"General","title":"General","text":"https://tldrlegal.com/license/gnu-affero-general-public-license-v3-(agpl-3.0)","category":"page"},{"location":"","page":"General","title":"General","text":"This program is free software for non-commercial applications:  you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.","category":"page"},{"location":"","page":"General","title":"General","text":"This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.","category":"page"},{"location":"","page":"General","title":"General","text":"You should have received a copy of the GNU Affero General Public License along with this program inside LICENSE file.  If not, see https://www.gnu.org/licenses/.","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"CollapsedDocStrings = true","category":"page"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/#gRNAs-and-kmers","page":"Utils","title":"gRNAs and kmers","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"getseq\nas_kmers\nas_skipkmers\nall_kmers\nminkmersize","category":"page"},{"location":"utils/#CHOPOFF.getseq","page":"Utils","title":"CHOPOFF.getseq","text":"getseq(n = 20, letters = ['A', 'C', 'G', 'T'])\n\nRandomize sequence of length n from letters.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CHOPOFF.as_kmers","page":"Utils","title":"CHOPOFF.as_kmers","text":"as_kmers(x::LongDNA{4}, kmer_size::Int)\n\nTransforms x into vector of kmers of size kmer_size.  All ambiguous bases will be expanded.\n\nExamples\n\njulia> as_kmers(dna\"ACTGG\", 4)\n2-element Vector{LongSequence{DNAAlphabet{4}}}:\n ACTG\n CTGG\n\n\n\n\n\n","category":"function"},{"location":"utils/#CHOPOFF.as_skipkmers","page":"Utils","title":"CHOPOFF.as_skipkmers","text":"as_skipkmers(x::LongDNA{4}, kmer_size::Int)\n\nTransforms x into vector of skip-kmers of size kmer_size.  All ambiguous bases will be expanded.  Leftover-bases are ignored!\n\nExamples\n\njulia> as_skipkmers(dna\"ACTGG\", 2)\n2-element Vector{LongSequence{DNAAlphabet{4}}}:\n AC\n TG\n\n\n\n\n\n","category":"function"},{"location":"utils/#CHOPOFF.all_kmers","page":"Utils","title":"CHOPOFF.all_kmers","text":"all_kmers(size = 4; alphabet = [DNA_A, DNA_C, DNA_G, DNA_T]\n\nMake a list of all possible kmers with givensize using bases in the alphabet. \n\nExamples\n\njulia> all_kmers(2; alphabet = [DNA_A, DNA_N])\n4-element Vector{LongSequence{DNAAlphabet{4}}}:\n AA\n AN\n NA\n NN\n\n\n\n\n\n","category":"function"},{"location":"utils/#CHOPOFF.minkmersize","page":"Utils","title":"CHOPOFF.minkmersize","text":"minkmersize(len::Int = 20, d::Int = 4)\n\nPigeon hole principle: minimum k-mer size that is required for two strings of size len to be aligned within distance of d.\n\nExamples\n\njulia> minkmersize(20, 3)\n5\n\njulia> minkmersize(20, 6)\n2\n\n\n\n\n\n","category":"function"},{"location":"utils/#Persistence","page":"Utils","title":"Persistence","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"save\nload","category":"page"},{"location":"utils/#CHOPOFF.save","page":"Utils","title":"CHOPOFF.save","text":"save(object::Any, destination::String)\n\nUses julia serializer to save the data to binary format. Read more about serialization. Notice that:\n\nThis function will overwrite destination! \nThis serialization is dependent on julia build! This means files can fail to work when reloaded across different julia builds.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CHOPOFF.load","page":"Utils","title":"CHOPOFF.load","text":"load(destination::String)\n\nLoad file saved with save function. This may not load properly files saved in other julia builds.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Summarize-off-targets","page":"Utils","title":"Summarize off-targets","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"summarize_offtargets","category":"page"},{"location":"utils/#CHOPOFF.summarize_offtargets","page":"Utils","title":"CHOPOFF.summarize_offtargets","text":"summarize_offtargets(res::DataFrame; distance::Int = maximum(res.distance))\n\nSummarize all off-targets into count table from the detail file. This does not automatically filters overlaps. You can specify distance to filter out some of the higher distances.\n\nArguments\n\nres - DataFrame created by one of the off-target finding methods, it contains columns      such as :guide,  :chromosome, :strand, :distance, :start. \n\ndistance - What is the maximum distance to assume in the data frame,      its possible to specify smaller distance than contained in the res DataFrame and autofilter lower distances.\n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"linearDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a linearDB\nbuild_linearDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"linearDB\", \"results.csv\")\nsearch_linearDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Proximity-filter","page":"Utils","title":"Proximity filter","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"filter_overlapping","category":"page"},{"location":"utils/#CHOPOFF.filter_overlapping","page":"Utils","title":"CHOPOFF.filter_overlapping","text":"filter_overlapping(res::DataFrame, distance::Int)\n\nFilter overlapping off-targets. Remember that off-targets have their start relative to the PAM location.\n\nArguments\n\nres - DataFrame created by one of the off-target finding methods, it contains columns      such as :guide,  :chromosome, :strand, :distance, :start. \n\ndistance - To what distance from the :start do we consider the off-target to be overlapping?\n\nExamples\n\nusing CHOPOFF, BioSequences\n\n# make a temporary directory\ntdir = tempname()\ndb_path = joinpath(tdir, \"linearDB\")\nmkpath(db_path)\n\n# use CHOPOFF example genome\nchopoff_path = splitpath(dirname(pathof(CHOPOFF)))[1:end-1]\ngenome = joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"genome\", \"semirandom.fa\"))\n\n# build a linearDB\nbuild_linearDB(\n    \"samirandom\", genome, \n    Motif(\"Cas9\"), \n    db_path)\n\n# load up example gRNAs\nguides_s = Set(readlines(joinpath(vcat(chopoff_path, \n    \"test\", \"sample_data\", \"guides.txt\"))))\nguides = LongDNA{4}.(guides_s)\n    \n# finally, make results!\nres_path = joinpath(tdir, \"linearDB\", \"results.csv\")\nsearch_linearDB(db_path, guides, res_path; distance = 3)\n\n# load results\nusing DataFrames, CSV\nres = DataFrame(CSV.File(res_path))\n\n# filter results by close proximity\nres = filter_overlapping(res, 23)\n\n# summarize results into a table of counts by distance\nsummary = summarize_offtargets(res; distance = 3)\n\n\n\n\n\n\n","category":"function"}]
}
